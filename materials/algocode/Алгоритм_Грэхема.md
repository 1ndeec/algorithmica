Алгоритм Грэхема базируется на следующей идее: Давайте не искать
следующую точку каждый раз, а сделаем так, чтобы у нас всегда
была оптимальная точка и мы могли бы просто ее достать и проверить.

В прошлом алгоритме мы искали точку, оптимальную по полярному углу,
тогда давайте сейчас сразу отсортируем точки по полярному углу и
сразу возьмем две первые точки в МВО.

Теперь будем делать следующий алгоритм, пока все точки не будут
просмотрены :

1\) Возьмем первую из отсортированных точек.

2\) Проверем последние три точки из взятых, если они образуют правый
поворот, то удалим предпоследнюю точку

Сделать это можно, например, стеком. Код есть ниже.

Асимптотика : Мы просмотрим одну точку и либо удалим ее, либо оставим,
то есть сам поиск МВО работает за линейное время, но мы еще делаем
сортировку, а $\\rightarrow$ алгоритм работает за $O(n\\log(n))$,
при этом его корректность вытекает из предыдущего алгоритма.

Красивая визуализация - <https://visualgo.net/en/convexhull>

красивое видео - <https://www.youtube.com/watch?v=BTgjXwhoMuI>

``` C++ numberLines
struct Point {
    int x, y;
};

Point operator -(Point a, Point b)
{
    return {a.x - b.x, a.y - b.y};
}

int operator * (Point a, Point b)
{
    return a.x * b.x + b.y * a.y;
}

int operator ^(Point a, Point b)
{
    return a.x * b.y - b.x * a.y;
}

bool cw(Point a, Point b, Point c)
{
    return (a - b) * (c - b) > 0;
}

bool ccw(Point a, Point b, Point c)
{
    return (a - b) * (c - b) < 0;
}

int main()
{
    sort(all(p2), comp);
    vector<Point> s;
    s.push_back(p[min_ind]);
    for (int i = 0; i < n - 1; i++) {
        if (p2[i].x == s[s.size() - 1].x && p2[i].y == s[s.size() - 1].y)
            continue;
        while (s.size() > 1 && (vect(s[s.size() - 1], s[s.size() - 2]) ^
               vect(s[s.size() - 1], p2[i])) > 0)
            s.pop_back();
        s.push_back(p2[i]);
    }
}
```