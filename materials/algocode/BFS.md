# BFS

BFS — breadth-first search, или же поиск в ширину.

## Алгоритм

Алгоритм работает следующим образом.

1\. Создадим массив $dist$ расстояний. Изначально $dist\[s\] = 0$
(поскольку расстояний от вершины до самой себя равно $0$) и
$dist\[v\] = \\infty$ для $v \\neq s$.

2\. Создадим очередь $q$. Изначально в $q$ добавим вершину $s$.

3\. Пока очередь $q$ непуста, делаем следующее:

a) Извлекаем вершину $v$ из очереди.

b) Рассматриваем все рёбра $(v, u) \\in E$. Для каждого такого ребра
пытаемся сделать релаксацию: если $dist\[v\] + 1 \< dist\[u\]$, то
мы делаем присвоение $dist\[u\] = dist\[v\] + 1$ и добавляем вершину
$u$ в очередь.

## Визуализации:

  - <https://visualgo.net/mn/dfsbfs>

<!-- end list -->

  - <https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/visualize/>

## Интуитивное понимание алгоритма

Можно представить, что мы поджигаем вершину $s$. Каждый шаг алгоритма —
это распространение огня на соседние вершины. Понятно, что огонь
доберётся до вершины по кратчайшему пути.

Заметьте, что этот алгоритм очень похож на DFS — достаточно заменить
очередь на стек и поиск в ширину станет поиском в глубину.
Действительно, оба алгоритма при обработке вершины просто
записывают всех непосещенных соседей, в которые из неё есть ребро,
в структуру данных, и после этого выбирает следующую вершину для
обработки в структуре данных. В DFS это стек (благодаря
рекурсии), поэтому мы сначала записываем соседа, идем в
обрабатываем его полностью, а потом начинаем обрабатывать
следующего соседа. В BFS это очередь, поэтому мы кидаем сразу всех
соседей, а потом начинаем обрабатывать вообще другую вершину - ту
непосещенную, которую мы положили в очередь раньше всего.

Оба алгоритма позволяют обойти граф целиком - посетить каждую вершину
ровно один раз. Поэтому они оба подходят для таких задач как:

  - поиск компонент связности
  - проверка графа на двудольность
  - построение остова

## Реализация

``` C++
vector<int> bfs(int s) {
    // длина любого кратчайшего пути не превосходит n - 1,
    // поэтому n - достаточное значение для "бесконечности";
    // после работы алгоритма dist[v] = n, если v недостижима из s
    vector<int> dist(n, n);
    dist[s] = 0;
    queue<int> q;
    q.push(s);

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int u : adj[v]) {
            if (dist[u] > dist[v] + 1) {
                dist[u] = dist[v] + 1;
                q.push(u);
            }
        }
    }

    return dist;
}
```

## Модификации и идеи

  - [Кратчайшее расстояние между двумя
    вершинами](Кратчайшее_расстояние_между_двумя_вершинами "wikilink")
  - [Кратчайшее расстояние от всех вершин графа до
    выделенных](Кратчайшее_расстояние_от_всех_вершин_графа_до_выделенных "wikilink")
  - [0-1 BFS](0-1_BFS "wikilink")
  - [1-k BFS](1-k_BFS "wikilink")