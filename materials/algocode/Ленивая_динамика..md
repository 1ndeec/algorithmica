## Ленивая динамика

Если сложно придумать порядок обхода таким образом, чтобы все предыдущие
значения уже были посчитаны, то можно вместо циклов использовать
рекурсивную функцию и запоминать посчитанный результат, чтобы не
считать несколько раз одно и то же.

Решим, например, обычную задачу о рюкзаке таким образом. Изначально все
$dp\[i\]\[j\]=-1$, это будет обозначать, что значение еще не посчитано,
кроме $dp\[0\]\[j\]=0$.

``` C++ numberLines
int calc(int i, int j) {
    if (dp[i][j] == -1) {
        dp[i][j] = calc(i - 1, j);
        if (a[i] <= j) {
            dp[i][j] = max(dp[i][j], calc(i - 1, j - a[i]) + c[I]);
        }
    }
    return dp[i][j];
}

answer = 0
for (int j = 0; j <= W; j++) {
    answer = max(answer, calc(n, j))};
}
```

Время работы так же составит $O(nW)$, так как каждое значение мы считаем
только один раз, но истинное время работы будет в несколько раз больше,
потому что константа на вызовы функции значительно выше чем на простой
цикл.

Также можно заметить, что в такой динамике мы посещаем только
действительно нужные состояния, что в некоторых задач
приводит к более приятной асимптотике.