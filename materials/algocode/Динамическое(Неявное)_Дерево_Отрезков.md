## Задача

Дана прямая длинной $n$ ($1 \\le n \\le 10^9$), есть запросы двух видов
:

Отметить на прямой все точки с координатами с $l$ по $r$, если точка уже
отмечена отмечать второй раз не нужно.

Вывести количество отмеченных точек на отрезке с $l$ по $r$.

## Идея

Все ранее рассмотренные задачи на Дерево отрезков мы разбирали на
массиве, когда все координаты были достаточно маленькие, что же
делать в случаях, когда координаты порядка 1e9.

## Асимптотика

Первым делом а давайте поймем сколько вообще отрезков мы создадим. На
каждый запрос мы создадим $O(\\log(n))$ отрезков, то есть суммарно
появится не более $O(q\\log(n))$ отрезков

## Наивная, но иногда хорошая работающая идея

Давайте хранить все состояния в unordered_map и создавать их только
тогда, когда они понадобятся

## Код

``` C++ numberLines
unordered_map<int, int> seg_tree;
//если вы обратитесь к элементу, которого нет в unordered_map, то он будет равен 0, то для данной задачи нам можно обращаться, как и в обычном ДО
```

## Альтернативный способ

Давайте создадим структуру, в которой будет хранится ответ на отрезке и
указатель на правого и левого сына или нулевой указатель, если их нет,
тогда вершина будет создаваться только тогда когда к ней есть запрос

## Оптимизация

У указателя есть некоторые проблемы, например на некоторых системах он
всегда занимает 8 байт и это может вызвать мл, поэтому можно хранить
вместо указателей массив структур и теперь указатель на левого и
правого сына это просто их индекс в массиве или -1, если они пока
не созданы

## Код

``` C++ numberLines
struct seg {
    int ans, l, r;
    seg() {
        ans = 0;
        l = -1;
        r = -1;
    }
};

seg seg_tree[SZ];
int sz = 0;

int get(..) {
     ..
     if (seg_tree[now].l == -1) {
         seg_tree[now].l = sz++;
     }
     if (seg_tree[now].r == -1) {
         seg_tree[now].r = sz++;
     }
     ..
}
```