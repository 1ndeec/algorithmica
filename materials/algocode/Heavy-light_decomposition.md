Техника $HLD$ позволяет декомпозировать дерево на пути таким образом,
что любой путь на дереве распадается на $O(\\log n)$ путей из
декомпозиции.

### Идея

Назовем ребро <i>тяжелым</i>, если оно ведет в сына с максимальным
размером (при равенстве размеров назовем <i>тяжелым</i> любое из
возможных). У вершины не должно быть больше одного тяжелого ребра.
Оставшиеся ребра назовем <i>легкими</i>.

Теперь рассмотрим путь от вершины $v$ до корня. На нем может быть
$O(\\log n)$ легких вершин, потому что если ребро $v \\rightarrow
parent_v$ легкое, то $size_{parent_v} \\ge 2 \\cdot size_v$. Таким
образом, если бы ребер на пути до корня будет больше логарифма, то
размер всего дерева не будет равен $n$.

Тогда разобьем дерево на пути, состоящие из тяжелых ребер. Любой запрос
на пути разбивается на $\\log$ запросов на вертикальных тяжелых путях.
На этих путях построим какую-нибудь структуру данных, которая поможет
нам отвечать на такие запросы (чаще всего это будет [дерево
отрезков](дерево_отрезков "wikilink")).

### Реализация

В реальности никто не пишет много разных деревьев отрезков, а все пути
скидываются в одно дерево. Как? Переупорядочим списки детей у каждой
вершины, поставив тяжелое ребро первым. Тогда если сделать [эйлеров
обход дерева](эйлеров_обход_дерева "wikilink"), выписав вершины в
порядке их $tin$-а, то пути из декомпозиции будут образовывать
подотрезки этого пути. Соответственно, можно построить всего одно
дерево отрезков.

<i>Примечание</i>. В такой реализации есть дополнительная возможность
применять операции к поддереву.

``` c++ numberLines
void dfs(int v, int p) {
    sz[v] = 1;
    int id = 0;
    for (int i = 0; i < g[v].size(); i++) {
        int to = g[v][i];
        dfs(to, v);
        sz[v] += sz[to];
        if (sz[to] > sz[g[v][id]]) {
            id = i;
        }
    }
    swap(g[v][id], g[v][0]);
}

/*
строим hld
up[v] -> первая вершина на
         вертикальном пути из тяжелых ребер,
         в котором лежит v
pos[i] хранит эйлеров обход дерева (только первое вхождение
*/

void build(int v, int p) {
    if (up[v] == -1) {
        up[v] = up[p];
    }
    pos[timer] = v;
    tin[v] = timer++;
    bool f = 0;
    for (auto to : g[v]) {
        if (f) {
            up[to] = to;
        }
        build(to, v);
        f = 1;
    }
    tout[v] = tin[v] + sz[v] - 1;
}

int lca(int v, int u);
bool parent(int v, int u);

void query_vert(int v, int u) {
    while (up[v] != up[u]) {
        get(up[v], v);
        v = parent[up[v]];
    }
    get(u, v);
}

void query(int v, int u) {
     query_vert(v, lca(v, u));
     query_vert(u, lca(v, u)); // аккуратно - вот тут можно дважды обработать lca.
}
```

[Категория:Конспекты](Категория:Конспекты "wikilink")