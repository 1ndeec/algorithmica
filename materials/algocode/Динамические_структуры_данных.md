Иногда в задачах требуется построить структуру данных на массиве очень
большого размера (таком, что он не помещается в память). При этом
известно, что количество запросов к структуре невелико. Типичная
задача: Дан массив размером $n\\ (1 \\le n \\le 10^9)$, изначально
заполненный нулями. Необходимо ответить на $q\\ (1 \\le q \\le 10^5)$
запросов одного из двух типов:

  - Изменить значение элемента.
  - Посчитать сумму на отрезке.

#### Решение

<i>Замечание</i>Мы умеем решать эту задачу с помощью дерева отрезков, но
сталкиваемся с недостатком памяти. Иногда это можно побороть, если
воспользоваться техникой [сжатия
координат](Сжатие_координат "wikilink"). Писать
неявное ДО в такой ситуации — стрелять из пушки по воробьям.

Сделаем в дереве отрезков ряд изменений. Во-первых, напишем его на
структурах и указателях. Каждая вершина дерева отрезков — это
объект, который хранит указатели на своего левого и правого сына.
Давайте решать эту задачу так, как мы решали бы ее обычным деревом
отрезков, но <b>не вызовем</b> операцию построения. То есть
изначально наше дерево отрезков — это корень. Создавать вершины
мы будем в операциях обновления, если вершина еще не была создана
(похожим на \[отложенные операции\] образом). При get-запросе
считаем, что если вершина не создана, то сумма в ней 0 (логично
ведь). Тогда за один запрос мы создадим $O(\\log n)$ вершин,
суммарно все будет работать за $O(q \\log n)$ времени и $O(q
\\log n)$ памяти.

``` c++ numberLines
struct segtree {
    segtree* l = nullptr, r = nullptr;
    int sum = 0;
};

segtree *root = new segtree();

segtree * make() {
    return new segtree();
}

int getsum(segtree* v) {
    if (v == nullptr) return 0;
    return v->sum;
}

void update(segtree* v, int tl, int tr, int pos) {
    if (tl + 1 == tr) {
        v->sum++;
                return;
    }
    if (v->l == nullptr) {
        v->l = make();
    }
    if (v->r == nullptr) {
        v->r = make();
    }
    int tm = (tl + tr) / 2;
    if (pos < tm) {
            update(v->l, tl, tm, pos);
    }
    else {
        update(v->r, tm, tr, pos);
    }
    v->sum = getsum(v->l) + getsum(v->r);
    return nw;
}

inline int get(segtree *v, int tl, int tr, int l, int r) {
    if (l >= tr || tl >= r || v == nullptr) {
                 return 0;
        }
        if (l <= tl && tr <= r) {
                  return v->sum;
        }
        int tm = (tl + tr) / 2;
        return get(v->l, tl, tm, l, r) + get(v->r, tm, tr, l, r);
}
```

#### Use Cases

Используемая в статье техника полезна при работе с:

  - [деревом отрезков](Дерево_отрезков "wikilink")
  - [деревом Ли Шао](Li_Chao_Tree "wikilink")

\[Категория:Структуры данных для запросов на отрезке\]