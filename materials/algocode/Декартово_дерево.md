Декартово дерево — это структура данных, реализующая двоичное дерево
поиска. Стандартный сценарий использования декартового дерева - это
реализация следующего функционала:

  - Вставка элемента в множество
  - Удаление элемента из множества
  - Нахождение элемента в множестве
  - Нахождение первого элемента, меньшего $x$
  - и многое-многое другое

#### Структура дерева

В каждой вершине мы будем хранить два числа — ключ $x$, по которому наша
структура будет бинарным деревом поиска, а также приоритет $y$, по
которому наше дерево будет кучей. Приоритеты нужно выбирать
случайно, на этом будет опираться оценка высоты дерева. Пока что
будем считать, что высота дерева $O(\\log n)$, но докажем это ниже.

#### Основные операции

Все операции с декартовым деревом реализуются с помощью двух основных —
$split$ и $merge$:

  - $split(t,\\ x)$ делит декартово дерево $t$ на два — в одном все
    ключи меньше $x$, все остальные вершины в другом.
  - $merge(l,\\ r)$ сливает два декартовых дерева в одно при условии,
    что все ключи в $l$ меньше, чем в $r$.

Реализовать $insert\\ x$ можно через

<code> l, r = split(t, x)

l = merge (x, new node(x))

t = merge (l, r) </code>

Аналогичным образом можно выразить и остальные операции.

#### merge

Делать merge будем так:

  - $merge(\\empty, t) = t$
  - $merge(t, \\empty) = t$
  - Теперь научимся делать $merge(l, r)$. Посмотрим на $l_y, r_y$.
    Если $l_y \> r_y$, то сделаем $l_r = merge(l_r, r)$. Иначе
    $r_l = merge(l, r_l)$. Нетрудно видеть, что таким образом мы
    получим бинарное дерево по $x$ и кучу на максимум по $y$.

#### split

Делать split будем так:

  - $split(\\empty, x) = \\empty$
  - Для непустого дерева сделаем так — посмотрим на значение $x$ в корне
    и решим, куда должен перейти корень — в левое или правое дерево.
    Осюда и выразим оба случая
  - если $t_x \< x$, то сделаем $split(t_r, x)$. Левый результат
    сделаем правым сыном $t$ и получим два итоговых дерева.
  - иначе сделаем $split(t_l, x)$, приклеим правый результат к $t$
    слева.

#### Реализация

У нас будет реализация, которая использует механизм ссылок в C++. Вместо
того, чтобы возвращать дерево (или даже пару деревьев) мы будем хранить
ссылку на переменную, в которую надо записать возвращаемые значения.
Это делает нашу реализацию проще для написания.

``` c++ numberLines
struct treap {
    treap *l = nullptr, *r = nullptr;
    int x;
    int y;
    treap(int x): x(x){
       y = get_random_int(); // your favorite random
    }
};

treap *root = nullptr;

void split(treap *t, treap *&l, treap *&r, int x) {
    if (t == nullptr) {
        l = nullptr;
        r = nullptr;
        return;
    }
    if (t->x < x) {
        split(t->r, t->r, r, x);
        l = t;
    }
    else {
        split(t->l, l, t->l, x);
        l = t;
    }
}

void merge(treap *&t, treap *l, treap *r) {
    if (l == nullptr) {
        t = r;
        return;
    }
    if (r == nullptr) {
        t = l;
        return;
    }
    if (l->y >= r->y) {
        merge(l->r, l->r, r);
        t = l;
    }
    else {
        merge(r->l, l, r->l);
        t = r;
    }
}
```

#### Функция в поддереве и массовые операции

Пока что наша структура данных была не сильно полезнее, чем $std::set$.
Заметим, что мы можем считать функции в поддереве (например, сумму),
которую можно вычислять, опираясь на значения в вершине и ее детях
(точно так же, как в [дереве отрезков](Дерево_отрезков "wikilink"). А
также мы можем сделать массовую операцию на декартовом дереве,
воспользовавшись техникой [отложенных
операций](Отложенные_операции "wikilink").

#### Неявный ключ

Заметим, что мы практически не пользовались ключами при работе с
декартовым деревом. Если точнее, то мы смотрели на него только в
$split$, когда решали, в правое или левое дерево должна перейти вершина.

Давайте попробуем сделать такой $split(t, x)$, который вернет два дерева
$l, r$ такие, что $size(l) = x$. Для этого нам надо будет считать
размеры поддеревьев (см. [предыдущий
пункт](Декартово_дерево#Функция_в_поддереве_и_массовые_операции "wikilink").):

  - $split(t, x)$, если $size(t_l) \> x$, требует от нас $split(t_l,
    x)$
  - иначе, $split(t, x)$, требует от нас $split(t_r, x - size(t_l) -
    1)$.

<!-- end list -->

``` c++ numberLines

struct treap {
    treap *l, *r;
    int sz;
    int y;
};

int getsz(treap *t) {
    if (t == nullptr) {
        return 0;
    }
    return t->sz;
}

void upd(treap *t) {
    if (t == nullptr) {
        return;
    }
    t->sz = getsz(t->l) + getsz(t->r) + 1;
}

void split(treap *t, treap *&l, treap *&r, int x) {
    if (t == nullptr) {
        l = nullptr;
        r = nullptr;
        return;
    }
    if (getsz(t->l) + 1 >= x) {
        split(t->l, l, t->l, x);
        r = t;
    }
    else {
        split(t->r, t->r, r, x - getsz(t->l) - 1);
        l = t;
    }
    upd(l);
    upd(r);
}

void merge(treap *&t, treap *l, treap *r) {
    if (l == nullptr) {
        t = r;
        upd(t);
        return;
    }
    if (r == nullptr) {
        t = l;
        upd(t);
        return;
    }
    if (l->y >= r->y) {
        merge(l->r, l->r, r);
        t = l;
    }
    else {
        merge(r->l, l, r->l);
        t = r;
    }
    upd(t);
}
```

#### Время работы

Все операции с декартовым деревом работают за $O(h)$, где $h$ — высота
дерева.

[Категория:Конспект](Категория:Конспект "wikilink")