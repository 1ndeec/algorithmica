---
title: Алгоритм Крускала
prerequisites:
- dsu
---

Отсортируем рёбра и будем пытаться добавлять их в остов в порядке возрастания их весов. Если ребро соединяет какие-то две уже соединенные вершины, то проигнорируем его, иначе оно является безопасным, и его можно добавить.

Звучит очень просто — отсортировать все рёбра, пройтись по ним циклом и делать проверку, что вершины в разных компонентах. Наивная проверка будет работать за $O(m \log m + n^2)$, но асимптотику можно улучшить до $O(m \log m)$ (до стоимости сортировки), если для проверок использовать систему непересекающихся множеств.

```c++
// (w, (a, b))
vector< pair< int, pair<int, int> > > edges;

sort(edges.begin(), edges.end());

for (auto e : edges) {
    int a = e.first.first, b = e.first.second;
    // компоненты разные, если лидеры разные
    if (p(a) != p(b)) {
        // добавим ребро (a, b)
        unite(a, b);
    }
}
```
