---
title: Система непересекающихся множеств
---

Система непересекающихся множеств (англ. *disjoint set union*) — структура данных, которая используется для хранения информации о связности компонент. Она нам потребуется для описания следующего подхода — алгоритма Крускала.

Изначально имеется несколько элементов, каждый из которых находится в отдельном (своём собственном) множестве. Структура поддерживает две операции:

- Объединить два каких-либо множества.
- Запросить, в каком множестве сейчас находится указанный элемент.

Обе операции выполняются в среднем почти за $O(1)$ (но не совсем — этот сложный вопрос будет разъяснен позже).

Множества элементов мы будем хранить в виде деревьев: одно дерево соответствует одному множеству. Корень дерева — это представитель (лидер) множества. Заведём массив `_p`, в котором для каждого элемента мы храним номер его предка в дереве. Для корней деревьев будем считать, что их предки — они сами.

Наивная реализация, которую мы потом ускорим:

```c++
int _p[maxn];

int p(int v) {
    if (_p[v] == v)
        return v;
    else
        return p(_p[v]);
}

void unite(int a, int b) {
    a = p(a), b = p(b);
    _p[a] = b;
}

for (int i = 0; i < n; i++)
    _p[i] = i;
```

**Эвристика сжатия пути**. Оптимизируем работу функции `p`. Давайте перед тем, как вернуть ответ, запишем его в `_p` от текущей вершины, то есть переподвесим его за самую высокую.

![Паблик «Странные опросы для спортивных программистов»](img/stasyan.jpg)

Следующие две эвристики похожи по смыслу и стараются оптимизировать высоту дерева, выбирая оптимальный корень для переподвешивания.

**Ранговая эвристика**. Будем хранить для каждой вершины её *ранг* — высоту её поддереа. При объединении деревьев будем делать корнем нового дерева ту вершину, у которой ранг больше, и пересчитывать ранги (ранг у лидера должен увеличиться на единицу, если он совпадал с рангом другой вершины). Эта эвристика оптимизирует высоту дерева напрямую.

**Весовая эвристика**. Будем вместо ранга хранить размеры поддеревьев для каждой вершины, а при объединении — подвешивать за более «тяжелую».

Финальная реализация, использующая весовую эвристику и эвристику сжатия путей:

```c++
int _p[maxn], s[maxn];

int p (int v) { return (_p[v] == v) ? v : _p[v] = p(_p[v]); }

void unite(int a, int b) {
    a = p(a), b = p(b);
    if (s[a] > s[b])
        swap(a, b);
    s[b] += s[a];
    _p[a] = b;
}

// где-то в main:

for (int i = 0; i < n; i++)
    _p[i] = i;
```

Автор предпочитает именно весовую эвристику, потому что часто в задачах размеры компонент требуются сами по себе.

### Асимптотика

Эвристика сжатия путей улучшает асимптотику до $O(\log n)$ в среднем. Здесь используется именно амортизированная оценка — понятно, что в худшем случае нужно будет сжимать весь бамбук за $O(n)$.

Индукцией несложно показать, что весовая и ранговая эвристики ограничивают высоту дерева до $O(\log n)$, а соответственно и асимптотику тоже.

При использовании эвристики сжатия плюс весовой или ранговой асимптотика будет $O(a(n))$, где $a(n)$ — обратная функция Аккермана (очень медленно растущая функция, для всех адекватных чисел не превосходящая 4).

Тратить время на изучения доказательства или даже чтения статьи на Википедии про функцию Аккермана автор не рекомендует.

## Персистентная СНМ

СНМ — структура данных на ссылках, и её тоже можно сделать персистентной. В СНМ мы изменяем массивы, а массивы можно сделать персистентными через персистентное ДО (только так, проще не получается — многие пытались).

Здесь есть нюанс — амортизированные структуры не очень хорошо дружат с персистентностью. Поэтому нам придется отказаться от эвристики сжатия путей, и поэтому асимптотика составит $O(n \log^2 n)$ времени и памяти — один логарифм от самого СНМа, другой от персистентного ДО.
