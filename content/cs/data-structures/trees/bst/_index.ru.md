---
title: Бинарные деревья поиска
weight: 2
---

Бинарное (двоичное) дерево поиска (англ. *binary search tree*, BST) — дерево, для которого выполняются следующие свойства:

- У каждой вершины не более двух детей.
- Все вершины обладают *ключами*, на которых определена операция сравнения (например, целые числа или строки).
- У всех вершин *левого* поддерева вершины $v$ ключи *не больше*, чем ключ $v$.
- У всех вершин *правого* поддерева вершины $v$ ключи *больше*, чем ключ $v$.
- Оба поддерева — левое и правое — являются двоичными деревьями поиска.

![Пример BST](/img/bst.svg)

Чаще всего бинарные деревья поиска хранят в виде структур — по одной на каждую вершину — в которых записаны ссылки на правого и левого сына (возможно, пустые), ключ и возможно какие-то дополнительные данные.

```cpp
struct Node {
    int x;
    Node *l, *r;
};
```

Как можно догадаться по названию, основное преимущество бинарных деревьев поиска в том, что в них можно легко производить поиск элементов:

```cpp
bool find(Node *v, int x) {
    if (!v)
        return false;
    if (v->x == x)
        return true;
    return (v->x < x) ? find(v->l, x) : find(v->r, x);
}
```

Эта функция — как и многие другие стандартные, например, вставка или удаление элементов — работает в худшем случае за высоту дерева. Высота бинарного дерева в худшем случае может быть $O(n)$ («бамбук»), поэтому в эффективных реализациях поддерживаются некоторые инварианты, гарантирующую *среднюю* глубину вершины $O(\log n)$ и соответствующую стоимость основных операций. Такие деревья называются *сбалансированными*.

## std::set

В STL конкретная реализация бинарного дерева представлена структурой `set`, поддерживающей множество уникальных упорядоченных элементов:

```cpp
set<int> s;

s.insert(3); // s = {3}
s.insert(2); // s = {2, 3}
s.size();    // вернет |s| = 2

s.insert(3); // 3 не будет добавлено ещё раз, так как уже присутствует в множестве
s.size();    // |s| = 2

// присутствует ли в множестве элемент:
s.count(3);  // вернет 1
s.count(5);  // вернет 0

s.erase(3);  // s = {2}
s.insert(6); // s = {2, 6}
```

Также `set` поддерживает итераторы. Начало `set` (наименьший элемент) можно получить через метод `begin`, конец — через метод `end` (но обратите внимание, что он, как и все итераторы, указывает на полуинтервал, то есть на несуществующий элемент, идущий после последнего). Инкремент и декремент итераторов работает за логарифмические время.

Тип всех итераторов — "set<T>::iterator", но так как это слишком громоздко писать, в современном C++ лучше использовать `auto`:

```cpp
auto it = s.find(2); // возвращает итератор на элемент или `end`, если элемента нет
++it;                // найти следующий элемент
int x = *it;         // x = 6 

s.lower_bound(1); // выведет 2, так как это первый элемент >= 1
s.upper_bound(2); // выведет 6, так как это первый элемент > 2

auto it = s.upper_bound(10);
if (it == s.end()) {
    // аккуратно: если разыменуете it, получите undefined behaviour!
}

// вывод всех элементов сета в порядке возрастания с использованием итераторов
for (auto it = s.begin(); it != s.end(); ++it)
    cout << *it << " ";

// но для таких целей лучше использовать range-based for loop
for (int x : s)
    cout << x << " ";
```

Так как `set` реализован как сбалансированное двоичное дерево поиска, все операции с его элементами работают за $O(\log n)$.

В STL есть несколько структур с таким же интерфейсом и немного отличающейся функциональностью:

- `map` ассоциирует с ключами значения и позволяет получать их как из бесконечных массивов: `m[x] = y`.
- `multiset` поддерживает дубликаты элементов. `.count(x)` у него возвращает количество элементов с заданным ключом, а не просто 0 или 1. Его можно реализовать как `map`, в котором в качестве ключей хранятся количества элементов.
- `multimap` возвращает по ключу много различных значений вместо одного и позволяет итерироваться по ним (то же самое, что использовать). Его можно реализовать как `map<A, vector<B>>`.

Также у всех этих контейнеров есть аналоги, работающие на [хэш-таблицах](../../hash-table) вместо BST: `unordered_set`, `unordered_map`, `unordered_set` и `unordered_multimap`. В них поиск, удаление и вставка в среднем работают за константное время, но нет `lower_bound` и упорядоченного итерирования.
