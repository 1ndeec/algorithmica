---
title: Branchless Programming
weight: 3
---

Branchless and sometimes branch-free.

Predication


---

Интересные примеры из реального мира:

1. Упрощенно, внутри структуры std::string есть указатель на выделенный где-то null-terminated отрезок массива чаров и size_t размер строки. Очень частое значение для строк — пустая строка, которую тоже нужно как-то обрабатывать. Вместо того, чтобы записать в качестве указателя пустой строки nullptr и делать в коде дорогую проверку «не является ли строка пустой», в компиляторе GCC просто выделено специальное место, в которой лежит нулевой байт, на адрес которого ссылаются все нулевые строки. Все процедуры со строками вынуждены читать этот бесполезный нулевой байт, но это получается дешевле, чем делать проверку.

2. Бинарный поиск можно написать без бранчей, и на маленьких (влезающих в кэш) данных он будет работать в ~4 раза быстрее и стандартного самописного бинпоиска, и std::lower_bound — причем как чистый drop-in replacement, без какой-либо перестановки данных. Нет никаких серьёзных причин, почему обычный бинарный поиск компилятор не может оптимизировать сам — в GCC и LLVM заведены баги про это, но разработчики разных частей компилятора заявляют «это должно оптимизироваться не на этой стадии, а раньше/позже» и уже много лет перевешивают ответственность друг на друга

https://bugs.llvm.org/show_bug.cgi?id=40027

---

(The compiler can't optimize it because it's technically [not allowed to](/hpc/compilation/contracts): despite `y - x` being valid, `x - y` could over/underflow, causing undefined behavior. Although fully correct, I guess the compiler just doesn't date executing it.)

---

В компиляторах есть способы, как сообщить, что бранч лучше заменить на cmov — __builtin_expect_with_probability(cond, true, 0.5) в GCC и __builtin_unpredictable(cond) в Clang — но оба теряются к тому моменту, когда оптимизатор решает, что выгоднее
