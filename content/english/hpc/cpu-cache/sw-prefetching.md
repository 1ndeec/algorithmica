---
title: Software Prefetching
weight: 1
---

Sometimes the hardware can't figure out what to prefetch next by itself, and in this case, we need to point it explicitly.

The easiest thing is to just use any byte in the cache line as an operand, but CPUs have an explicit instruction to just "lift" a cache line without doing anything with it. As far as I know, this instruction is not a part of the C/C++ standard or any other language, but is widely available in compilers.

It turned out it is non-trivial to design such a permutation case that simultaneously loops around all the array, can't be predicted by hardware prefetching but the next address is easily computable in order to do prefetching.

Luckily, LCG can be used. It is a known property that if ..., then the period will be exactly $n$. So, we will modify our algorithm so that the permutation is generated by LCG, using current index as the state:

```cpp
const int n = find_prime(N);

for (int i = 0; i < n; i++)
    q[i] = (2 * i + 1) % n;
```

Running it, the performance is the same as with the fully random permutation. But now we have the capability of peeking a bit ahead:

```cpp
int k = 0;

for (int t = 0; t < K; t++) {
    for (int i = 0; i < n; i++) {
        __builtin_prefetch(&q[(2 * k + 1) % n]);
        k = q[k];
    }
}
```

It is almost 2 times faster, as we expected.

![](../img/sw-prefetch.svg)

Interestingly, we can cut it arbitrarily close (to the cost of computing the next index â€” [modulo is expensive](../arithmetic/integer)).

One can show that in order to load $k$-th element ahead, we can do this:

```cpp
__builtin_prefetch(&q[((1 << D) * k + (1 << D) - 1) % n]);
```

Managing issues such as integer overflow, we can cut latency down arbitrarily close to just calculating the address using the formula.

![](../img/sw-prefetch-others.svg)

<!--
Instruction Cache. Unrolling loops. Aligning. No-op.
-->