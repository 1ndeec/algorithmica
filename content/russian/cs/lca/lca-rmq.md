---
title: Сведение LCA к RMQ
---

Подойдём к задаче нахождения наименьшего общего предка с другой стороны.

Пройдёмся по дереву dfs-ом и выпишем два массива: глубины вершин и номера вершин. Записывать мы их будем как когда при входе в вершину, так и при выходе.

Пусть теперь поступил запрос: найти LCA вершин $v$ и $u$. Для определенности предположим, что $tin_v < tin_u$, то есть $v$ в обходе встретилась раньше. Посмотрим на часть выписанного пути между моментом, когда мы вышли из $v$ и моментом, когда мы в первый раз вошли в $u$. Где-то на этом отрезке мы должны были прийти в наименьший общий предок, так как любой простой путь между двумя вершинами в дереве единственный. При этом мы на этом пути не поднимались куда-то выше LCA, а значит LCA — это самая высокая вершина на этом пути.

Получается, что чтобы найти LCA, можно найти позицию минимума на отрезке $[tout_v, tin_u]$ в массиве глубин (первый выписанный массив) и посмотреть, какой вершине она соответствует в эйлеровом обходе (второй выписанный массив). Таким образом, задачу LCA можно свести к задаче RMQ (нахождению минимума на отрезке), что можно сделать тем же деревом отрезков.

### Разреженная таблица

На практике асимптотику мы особо не улучшили — пока что всё равно требуется $O(\log n)$ времени на запрос в дерево отрезков, хоть преподсчёт и будет уже линейным.

Асимптотику времени запроса можно улучшить, используя тот факт, что мы на самом деле решаем задачу static RMQ, то есть у нас нет изменений этого массива. Для этого есть более подходящая структура — разреженная таблица. Она позволяет отвечать на запрос минимума за $O(1)$, но использует $O(n \log n)$ операций на препроцессинг (с малой константой). Подробнее про неё можно почитать в [отдельной статье](sparse-table).
