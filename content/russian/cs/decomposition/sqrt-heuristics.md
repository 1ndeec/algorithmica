---
title: Корневые эвристики
---


Корневые эвристики — это обобщённое название различных методов и структур данных, опирающихся на тот факт, что если мы разделим какое-то множество из $n$ элементов на блоки по $\sqrt{n}$ элементов, то самих этих блоков будет не более $\sqrt{n}$.

Центральное равенство этой статьи: $\sqrt x = \frac{x}{\sqrt x}$.

## Деление на тяжелые и легкие объекты

Всем известный алгоритм факторизации за корень опирается на тот факт, что каждому «большому» делителю $d \geq \sqrt n$ числа $n$ соответствует какой-то «маленький» делитель $\frac{n}{d} \leq n$.

Подобное полезное свойство (что маленькие объекты маленькие, а больших объектов не много) можно найти и у других объектов.

### Длинные и короткие строки

[710F. Операции над множеством строк](https://codeforces.com/contest/710/problem/F). Требутся в онлайне обрабатывать три типа операций над множеством строк:

1. Добавить строку в множество.
2. Удалить строку из множества.
3. Для заданной строки, найти количество её вхождений как подстроку среди всех строк множества.

Одно из решений следующее: разделим все строки на *короткие* ($|s| < \sqrt l$) и *длинные* ($|s| \geq \sqrt l$), где $l$ означает суммарную длину всех строк. Заметим, что длинных строк немного — не более $\sqrt l$.

С запросами будем справляться так:

* Заведём хэш-таблицу, и когда будем обрабатывать запрос добавления или удаления, будем прибавлять или отнимать соответственно единицу по [хэшам](hashing) всех её коротких подстрок. Это можно сделать суммарно за $O(l \sqrt l)$: для каждой строки нужно перебрать $O(\sqrt l)$ разных длин и окном пройтись по всей строке.

* Для запроса третьего типа для короткой строки, просто посчитаем её хэш и посмотрим на значение в хэш-таблице.

* Для запроса третьего типа для длинной строки, мы можем позволить себе посмотреть на все неудалённые строки, потому что таких случаев будет немного, и если мы можем за линейное время найти все вхождения новой строки, то работать это будет тоже за $O(l \sqrt l)$. Например, можно посчитать [z-функцию](string-searching) для всех строк вида $s\#t$, где $s$ это строка из запроса, а $t$ это строка из множества; здесь, правда, есть нюанс: $s$ может быть большой, а маленьких строк $t$ много — нужно посчитать z-функцию сначала только от $s$, а затем виртуально дописывать к ней каждую $t$ и досчитывать функцию.

Иногда отдельный подход к тяжелым и лёгким объектам не требуется, но сама идея помогает увидеть, что некоторые простые решения работают быстрее, чем кажется.

### Треугольники в графе

Рассмотрим другую задачу:

> Дан граф из $n$ вершин и $m \approx n$ рёбер. Требуется найти в нём количество циклов длины три.

Будем называть вершину *тяжелой*, если она соединена с более чем $\sqrt n$ другими вершинами, и *лёгкой* в противном случае.

Попытаемся оценить количество соединённых вместе троек вершин, рассмотрев все возможные 4 варианта:

0. В цикле нет тяжелых вершин. Рассмотрим какое-нибудь ребро $(a, b)$ цикла. Третья вершина $c$ должна лежать в объединении списков смежности $g_a$ и $g_b$, а раз обе эти вершины лёгкие, то таких вершин найдётся не более $\sqrt n$. Значит, всего циклов этого типа может быть не более $O(m \sqrt n)$.

1. В цикле одна тяжелая вершина. Аналогично — есть одно «лёгкое» ребро, а значит таких циклов тоже $O(m \sqrt n)$.

2. В цикле две тяжелые вершины — обозначим их как $a$ и $b$, а лёгкую как $c$. Зафиксируем пару $(a, c)$ — способов это сделать $O(m)$, потому что всего столько рёбер. Для этого ребра будет не более $O(\sqrt n)$ рёбер $(a, b)$, потому что столько всего тяжелых вершин. Получается, что всего таких циклов может быть не более $O(m \sqrt n)$.

3. Все вершины тяжелые. Аналогично — тип третьей вершины в разборе предыдущего случая нигде не использовался; важно лишь то, что тяжелых вершин $b$ немного.

Получается, что циклов длины 3 в графе может быть не так уж и много — не более $O(m \sqrt n)$.

Само решение максимально простое: отсортируем вершины графа по их степени, ориентируем ребра $v \rightarrow u, v \le u$; теперь внутренним циклом будем перебирать пути $v \rightarrow u \rightarrow w, v \le u \le w$, а потом проверять существование ребра $v \rightarrow w$.

```c++
vector<int> g[maxn], p(n); // исходный граф и список номеров вершин
iota(p.begin(), p.end(), 0); // 0, 1, 2, 3, ...

// чтобы не копипастить сравнение:
auto cmp = [&](int a, int b) {
    return g[a].size() < g[b].size() || (g[a].size() == g[b].size() && a < b);
};

// в таком порядке мы будем перебирать вершины
sort(p.begin(), p.end(), cmp);

// теперь удалим все лишние рёбра (ведущие в более тяжелые вершины)
for (int v = 0; v < n; v++) {
    vector<int> &t = g[v];
    // отсортируем их и удалим какой-то суффикс
    sort(t.begin(), t.end(), cmp);
    while (t.size() > 0 && cmp(t.back(), v))
        t.pop_back();
    reverse(t.begin(), t.end());
}

// рядом с каждой вершиной будем хранить количество
// ранее просмотренных входящих рёбер (v -> w)
vector<int> cnt(n, 0);
int ans = 0;

for (int v : p) {
    for (int w : g[v])
        cnt[w]++;
    for (int u : g[v])
        for (int w : g[u])
            ans += cnt[w]; // если в графе нет петель, то cnt[w] это 0 или 1
    // при переходе к следующему v массив нужно занулить обратно
    for (int w : g[v])
        cnt[w]--;
}
```

Задачу также можно было решить чуть более прямолинейно, переместив все проверки внутрь основного цикла, но это сказалось бы на скорости работы.

### Рюкзак за $O(S \sqrt S)$

Если у нас есть $n$ предметов с весами $w_1$, $w_2$, $\ldots$, $w_n$, такими что $\sum w_i = S$, то мы можем решить задачу о рюкзаке за время $O(S \cdot n)$ стандартной динамикой. Чтобы решить задачу быстрее, попытаемся сделать так, чтобы число предметов $n$ стало $O(\sqrt S)$.

Заметим, что количество различных весов среди будет $O(\sqrt S)$, потому что если среди них есть $k$ различных чисел, то:

$$
S = w_1 + w_2 + \ldots + w_n \geq 1 + 2 + \ldots + k = \frac{k \cdot (k+1)}{2}
$$

Откуда значит, что $k \leq 2\sqrt S$.

Рассмотрим теперь некоторый вес $x$, который $k$ раз встречается в наборе весов. «Разложим» $k$ по степеням двойки и вместо всех $k$ вхождений этого веса добавим веса $x$, $2 \cdot x$, $4 \cdot x$, $\ldots$, $(c - 1 - 2^t) \cdot x$, где $t$ это максимальное целое число, для которого выполняется $2^t − 1 \leq c$. Легко видеть, что все суммы вида $q \cdot x$ ($q \leq k$) и только их по-прежнему можно набрать.

Алгоритм в этом и заключается — проведем данную операцию со всеми уникальными значениями весов и после чего запустим стандартное решение. Уже сейчас легко видеть, что новое количество предметов будет $O(\sqrt S \log S)$, потому что для каждого веса мы оставили не более $\log S$ весов, а всего различных весов было $O(\sqrt S)$.

**Упражнение.** Доказать, что предметов на самом деле будет $O(\sqrt S)$.

**Примечание.** Классическое решение рюкзака можно ускорить на несколько порядков, если использовать [bitset](bitset) или [векторизовать](sse) его основной цикл.


---

Иногда асимптотики «тяжелой» и «лёгкой» части получаются разными, потому что мы где-то не смогли обойтись без какой-нибудь структуры, которая внесла лишний логарифм. Чаще всего, в качестве оптимального размера блока $c^*$ можно взять что-то близкое к решению уравнения $g \cdot \frac{n}{c} = f \cdot c$, где $f$ и $g$ это асимптотики блочной и не-блочной частей соответственно.

Впрочем, надо также учитывать, что походы в какое-нибудь декартово дерево совсем не в логарифм раз медленнее линейного прохода по массиву.


---

Иногда в задаче возникают ситуации, когда мы умеем решать ее когда
какое-то свойство \< $\\sqrt{N}$ и больше $\\sqrt{N}$. Данный
подход и называется корневой декомпозицией(оптимизацией).

Самыми простыми и наиболее известными применениями данной оптимизации
являются : алгоритм проверки на простоту чисел(рассмотрим делители \<
$\\sqrt{N}$ и больше, но так как для любого делителя больше корня можно
найти делитель меньше корня =\> нам надо честно рассмотреть только
первые) и например факт, что если суммарная длина строк = $N$, то
различных длин строк будет не более $\\sqrt{N}$ или если вы увидели
ограничение $A \* B \<= N$, то одно из чисел \< $\\sqrt{N}$.

Данные идеи очень полезны в задачах, где есть ограничение на суммарный
размер строк. Обозначим это ограничение за $\\sum |S|$.

#### Разбиение на длинные и короткие строки

Назовем строку $S \\ \\textit{длинной}$, если $|S| \\ge \\sqrt{\\sum
|S|}$. Все оставшиеся строки назовем $\\textit{короткими}$.

Иногда в задаче возникают ситуации, когда мы умеем решать ее когда
какое-то свойство \< $\\sqrt{N}$ и больше $\\sqrt{N}$. Данный
подход и называется корневой декомпозицией(оптимизацией).

Самыми простыми и наиболее известными применениями данной оптимизации
являются : алгоритм проверки на простоту чисел(рассмотрим делители \<
$\\sqrt{N}$ и больше, но так как для любого делителя больше корня можно
найти делитель меньше корня =\> нам надо честно рассмотреть только
первые) и например факт, что если суммарная длина строк = $N$, то
различных длин строк будет не более $\\sqrt{N}$ или если вы увидели
ограничение $A B \\le N$, то одно из чисел \< $\\sqrt{N}$.

#### Тяжелые и легкие вершины

Назовем $\\textit{тяжелой}$ вершину, имеющую более $\\sqrt{E}$ соседей.
Все оставшиеся вершины назовем $\\textit{легкими}$. {2} = E$</nowiki>,
чего не может быть. }}

#### Нахождение количества треугольников в графе за $O(E \\sqrt E)$

Мысленно разобьем все вершины графа на легкие и тяжелые. Заметим, что
треугольников, образованных только тяжелыми вершинами, всего
$O(E\\sqrt{E})$, как $C^3_{\\sqrt{E}}$. Теперь рассмотрим треугольники,
которые содержат в себе легкие вершины. В таком треугольнике точно будут
два ребра, инцидентных легкой вершине. Сколько таких пар может быть?
Всего таких ребер $O(E)$, при этом для каждого ребра парными могут
быть только $O(\\sqrt{E})$ ребер, в силу степени легкой вершины. Таким
образом, \\textit{число треугольников в графе равно} $O(E \\sqrt{E})$.
Каким алгоритмом их искать? Можно явно провести процесс, описанный
выше, но это не самое приятное в реализации решение этой задачи.

Можно переориентировать ребра от вершин с меньшей степенью к вершинам с
большей. Теперь верно следующее

Теперь для каждой вершины пометим ее соседей, после чего запустим поиск
путей длины 2 и будем фиксировать треугольник при нахождении пометки.
Для каждого первого ребра пути мы посмотрим на $O(\\sqrt E)$ ребер,
поэтому итоговая сложность алгоритма $O(E \\sqrt E)$

[Категория:Конспект](Категория:Конспект "wikilink")

Теперь обсудим еще одно решение задачи прибавления и суммы на отрезке.
Допустим, что все запросы даны нам заранее и запросов обновления нет.
Для каждого запроса закинем его в блок, где лежит его левая граница:

``` C++
s_dec[l / s].a.push_back({l, r});
```

Затем внутри каждого блока отсортируем запросы по правой границе. Теперь
давайте пройдемся по каждому блоку, поддерживая текущий отрезок, на
который мы знаем ответ. И если текущий отрезок равен отрезку из
запроса запоминать его, как ответ.

``` C++
struct q {
    int l, r, index;
};

struct block {
    vector<q> a;
};

for(int i = 0; i < q; i++) {
    s_dec[l / s].a.push_back({l, r, i});
}

for(int i = 0; i < s; i++) {
    sort(all(s_dec[i].a), comp);
}

for(int i = 0; i < s; i++) {
    int l = i * s, r = i * s;
    int ans = 0;
    for(int j = 0; j < s_dec[i].a.size(); j++) {
        int tl = s_dec[i].a[j].l, tr = s_dec[i].a[j].r;
        while(r > tr) {
            r--;
            ans -= a[r];
        }
        while(r < tr) {
            ans += a[r];
            r++;
        }
        while(l > tl) {
            l--;
            ans += a[l];
        }
        while(l < tl) {
            ans -= a[l];
            l++;
        }
        answ[s_dec[i].a[j].index] = ans;
}
```

Подумаем над асимптотикой данного алгоритма, для каждого запроса левая
граница пройдет не более, чем длину блока, но при этом правая граница
идет только вперед, а следовательно для одного блока пройдет не более,
чем длину массива, то есть суммарно алгоритм работает за $O(M\\sqrt{N}
+ M\\sqrt{N})$, если размер блока - $\\sqrt{N}$.

Алгоритм Мо может помочь нам в ответе на гораздо более сложные вопросы -
$k$-ая статистика на отрезке, медиана отрезка, наиболее встречающийся
элемент на отрезке и так далее.

Также существуют такие модификации алгоритма Мо, как [Мо
онлайн](Мо_онлайн "wikilink"), [3-Д мо](3-Д_мо "wikilink"),
[Мо на деревьях](Мо_на_деревьях "wikilink").  [Категория:Структуры
данных](Категория:Структуры_данных "wikilink")
[Категория:Конспекты](Категория:Конспекты "wikilink")
