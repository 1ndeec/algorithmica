Давайте теперь разбивать на сам массив, а запросы к нему. Например, у
нас есть такая структура, как префиксные суммы, которая позволяет
находить сумму на отрезке за $O(1)$ без запросов обновления, мы
можем честно пересчитывать ее каждый $\\sqrt{M}$ запросов.

Теперь поговорим о самих запросах:

Так как мы пересчитываем префиксные суммы каждые $\\sqrt{M}$ запросов,
то мы не рассмотрели все запросы, лежащие после предыдущего
обновления, таких запросов не может быть больше $\\sqrt{M}$,
то есть мы можем явно хранить список еще не обработанных запросов.

Тогда если мы встречаем запрос обновления, то просто добавим его в
список, требующий обновления.

В случае запроса суммы просто возьмем ответ с помощью префиксных сумм и
прибавим ответы на запросы.

\<syntaxhighlight lang='c++' line='line\> for (int i = 0; i \< q; i++) {

`   if (i % K == 0) {`
`        rebuild();`
`   }`
`   query q;`
`   cin >> q;`
`   if (q.type == "update") {`
`       buffer.push_back(q);`
`   }`
`   else {`
`       int ans = a[q.pos];`
`       for (auto x : buffer) {`
`           if (q.l <= x.pos && x.pos <= q.r) {`
`              ans += x.add;`
`           } `
`       }`
`       cout << ans << '\n';`
`   }`

}

</syntaxhighlight>

[Категория:Конспекты](Категория:Конспекты "wikilink")
[Категория:Корневая](Категория:Корневая "wikilink")