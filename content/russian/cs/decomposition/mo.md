---
title: Алгоритм Мо
authors:
- Сергей Слотин
prerequisites:
- sqrt-heuristics
---

*Алгоритм Мо* (кит. 莫隊算法) вероятно не был открыт, но точно был популяризован китайским спортивным программистом Мо Тао (莫涛) и его сокомандниками в конце нулевых годов.

Он позволяет в оффлайн отвечать на самые разные запросы на подотрезках, которые часто невозможно решить даже самыми продвинутыми структурами данных.

Для примера рассмотрим такую задачу: дан массив размера $n$ целых чисел от $1$ до $n$, и требуется отвечать на $q$ заранее известных запросов «количество различных чисел на отрезке $[l_i, r_i]$».

### Алгоритм

Если [корневая эвристика по запросам](../rollback) группирует запросы по временным признакам, то алгоритм Мо — по пространственным.

Сгруппируем все запросы в блоки размера $c \approx \sqrt n$ по их левой границе и внутри каждого блока отсортируем запросы по правой границе:

```cpp
// границы и номер запроса, на который нужно ответить
struct query { int l, r, idx; };

int a[maxn], ans[maxq]; // исходный массив и массив ответов на запросы
vector<query> b[c];


// где-то в main:

for (query q : queries)
    b[q.l / c].push_back(q);

for (int i = 0; i < c; i++) {
    sort(b[i].begin(), b[i].end(), [](query a, query b){
        return a.r < b.r;
    });
}
```

Будем обрабатывать каждый такой блок запросов по отдельности, заведя следующие переменные:

- границы $[l, r]$ текущего отрезка (изначально пустого: $l = i \cdot c$ и $r = i \cdot c - 1$);
- массив `cnt`, размера $n$, в котором для каждого значения хранится число элементов на текущем отрезке с данным значением (изначально заполнен нулями);
- переменная `res`, равная числу различных элементов на текущем отрезков, то есть числу ненулевых элементов массива `cnt` (изначально ноль).

Массив `cnt` и переменную `res` легко пересчитать за $O(1)$ при расширении или сжатии границ на единицу: 

```cpp
int cnt[maxn];
int res;

void add(int k) {
    if (cnt[a[k]]++ == 0)
        res++;
}

void del(int k) {
    if (--cnt[a[k]] == 0)
        res--;
}
```

Будем медленно двигать границы влево и вправо таким образом, чтобы текущий отрезок в какой-то момент времени был равен каждому отрезку-запросу, и в этот момент времени мы ответим на запрос, записав `res` в нужную ячейку массива ответов `ans`.

А именно, будем двигать правую границу текущего отрезка, пока она не станет равной правой границе очередного запроса (они отсортированы по правой границе), а затем будем двигать левую границу вправо или влево, пока она не совпадет с его левой границей:

```c++
for (int i = 0; i < c; i++) {
    // обнуляем переменные
    int l = i * c, r = i * c - 1;
    memset(cnt, 0, sizeof cnt);
    res = 0;
    for (query q : b[i]) {
        // пока правая граница не дошла до границы запроса
        while (r < q.r)
            add(++r);
        // дальше делаем так, чтобы левая граница совпала
        while (l < q.l)
            del(l++);
        while (l > q.l)
            add(--l);
        ans[q.idx] = res;
    }
}
```

Трюк в том, что правая граница суммарно сдвинется на $O(n)$, потому что отрезки отсортированы, а левая каждый раз сдвинется не более чем на $O(\sqrt n)$, так как все левые границы сгруппированы по корневым блокам. Изменение левых границ суммарно по всем блокам займёт $O(q \sqrt n)$ операций, а правых $O(n \sqrt n)$, так что итоговая асимптотика решения будет $O(q \sqrt n + n \sqrt n)$.

### Вариации

Конкретно для этой задачи этот алгоритм не нужен, однако он полезен для ответа на более сложные вопросы: найти $k$-ую порядковую статистику на отрезке, его медиану, количество различных элементов, наиболее часто встречающийся элемент и так далее. Во всех этих случаях нужно просто вместо суммы поддерживать какую-нибудь структуру — например, хэш-таблицу — отвечающую за множество элементов на отрезке, и пересоздавать её между блоками.

**На деревьях.** В некоторых задачах требуется считать результаты операций на дереве. Например: рядом с каждой вершиной есть число, и нам нужно возвращать количества различных значений на путях.

cs/trees/tree-queries/

Идея примерно такая же, как при [сведении LCA к RMQ](.cs/trees/lca-rmq). Мы можем выписать эйлеров обход дерева (каждую вершину выписываем дважды — в моменты входа и выхода), и теперь задача сводится к задаче на массиве, только с одним исключением: мы должны добавлять в структуру только те элементы, которые содержатся на отрезке ровно 1 раз.

**Использовать корневую декомпозицию как структуру.** Часто от внутренней структуры в алгоритме Мо требуется что-то сложное, и мы пребегаем к использованию каких-то «тяжелых» структур, вроде дерева отрезков. Но данный случай отличается от обычных задач на обработку запросов: у нас обновлений $O(n \sqrt n)$, а запросов всего $O(n)$. Здесь эффективнее вместо дерева отрезков, требующего $O(\log n)$ времени на оба типа запросов, взять структуру, которая быстро работает при обновлениях, и не очень быстро на самих запросах — например, корневую декомпозицию, которая работает за $O(1)$ и $O(\sqrt n)$ соответственно.

На самом деле, это примерно единственное место, где корневую эвристику как структуру использовать эффективнее всего — внутри другой корневой эвристики.

**«3D Мо».** Если очень захотеть, этот подход можно применять и в задачах, где надо обрабатывать запросы обновления. Для этого нужно ввести третий параметр get-запроса $t$, который будет равен числу update-запросов до текущего get.

Снова отсортируем все get-запросы, но на этот раз в порядке $(\frac{t}{n^{\frac 2 3}}, \frac{l}{n ^{\frac{2}{3}}}, r)$, и обработаем их таким же алгоритмом, только в трёх измерениях. Время работы нового подхода будет $O(n^{\frac{5}{3}})$, что доказывается аналогично исходному алгоритму.

Оказывается, если очень захотеть, [алгоритм Мо](алгоритм_Мо "wikilink")
можно применять и в задачах, где надо обрабатывать запросы обновления.
Введем третий параметр \`get\`-запроса -- t, который будет равен числу
\`update\`-запросов до текущего \`get\`. Снова пересортируем
\`get\`-запросы, но в этот раз в порядке
$(\\frac{t}{n^\\frac{2}{3}}, \\frac{l}{n^\\frac{2}{3}}, r)$. После чего
оставим такой же \[алгоритм Мо\], как и раньше, только в трех
измерениях. Единственное что -- теперь при переключении между
версиями массива надо будет менять ровно один элемент, и иногда менять
его в структуре, если он принадлежал текущему отрезку.
