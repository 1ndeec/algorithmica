---
title: Многоугольники
weight: 4
---

Благодаря этим свойствам, почти все проверки в геометрии можно описать через них, а не уравнениями.

**Принадлежность точки треугольнику**. Пусть у нас есть треугольник $ABC$ (заданный против часовой стрелки) и точка $P$. Тогда она должна лежать слева от всех трёх векторов $AB$, $BC$ и $CA$. Это условие задаст пересечение трёх полуплоскостей, которое и будет нужным треугольником.

$$
\text{P лежит внутри ABC} \iff \begin{cases}
(B-A) \times (P-A) \geq 0 \\
(C-B) \times (P-B) \geq 0 \\
(A-C) \times (P-C) \geq 0 \\
\end{cases}
$$

**Площадь треугольника**. Можно пользоваться готовыми формулами, а можно и свойством векторного произведения.

$$
V = \frac{1}{2} (B-A) \times (C-A)
$$

**Площадь произвольного многоугольника**. Если многоугольник задан последовательностью вершин в каком-то порядке, то можно считать так: для каждого ребра добавим его ориентированную площадь от начала координат. Какие-то слагаемые будут положительными (которые на последнем слое, а какие-то — отрицательными).

![any](https://habrastorage.org/getpro/habr/post_images/1b3/b00/8c0/1b3b008c0c074b0e38111a95ad421605.jpg)

Забудьте о формуле Герона и всегда считайте площади через векторное произведение.

Кстати, из формулы для площади треугольника следует, что площадь любой фигуры будет либо целым числом, либо рациональным с двойкой в знаменателе. Часто в в задачах входные данные целочисленные, и, чтобы оставаться в целых числах, когда мы считаем какую-нибудь площадь, иногда имеет смысл умножить все входные числа на $2$ (см. «точность»).

**Проверка на выпуклость**. Можно пройтись по сторонам многоугольника и проверять векторным произведением, что мы поворачиваем всегда в одну сторону, то есть для всех последовательных точек $a$, $b$, $c$ проверить, что $(b-a)\times(c-a) > 0$.


# Нахождение площади многоугольника без самопересечений

Рассмотрим два самых популярных способа — метод трапеций и суммирование
ориентированных площадей треугольников.

## Метод трапеций

[400px](Файл:Trapeze.png "wikilink") Будем рассматривать вершины и
стороны многоугольника в порядке обхода по или против часовой
стрелке. Допустим, будем обходить по часовой стрелке.

Опустим из каждой вершины перпендикуляр на ось OX. Если рассмотреть
сторону (например, $AB$), то ей можно сопоставить прямоугольную
трапецию, у которой одна боковая сторона лежит на оси OX, а другая
совпадает со стороной многоугольника. Например, для стороны AB будет
трапеция $ABHG$.

Двигаясь в порядке обхода по сторонам многоугольника, будем суммировать
площади таких трапеций.

Как проводить суммирование: пусть $x\[i\]$ и $y\[i\]$ - координаты точки
$i$. Прибавляться будет величина $$ \\Delta S = \\dfrac{(x\[i + 1\] -
x\[i\]) \\cdot (y\[i\] + y\[i + 1\])}{2} $$ При движении от точки A по
верхней огибающей вправо у нас будет появляться изюбток площади,
потому что координаты по $x$ увеличивались (допускаем, что весь
многоугольник лежит в верхней полуплоскости). То есть мы будем
прибавлять лишнюю площадь под фигурой. Этот избыток будет
компенсирован при движении по нижней огибающей от точки $D$
влево. При этом движении $\\Delta S \< 0$, в чем легко убедиться.

Если смотреть на пример, то площади трапеций $DLJE$, $EJIF$ и $IFAG$
будут идти со знаком \<<минус>\> и \<<уберут>\> лишнюю площадь,
добавленную до этого.

Надо не забыть обработать последнее ребро, соединяющее первуюю и
последнюю точки. Также в зависимости от порядка обхода и
расположения многоугольника площадь может иметь разный знак,
поэтому надо брать в конце модуль.

Очевидно, что для вычисления площади достаточно одного прохода по всем
точкам, поэтому время работы составит $O(n)$, где $n$ - число вершин в
многоугольнике.

## Метод треугольников

[400px](Файл:TrianglesSquare.png "wikilink") В целом этот способ похож
на предыдущий. Тут нам понадобится знание о векторном произведении
векторов и ориентированной площади треугольника. Будем считать, что
читателю это уже известно.

Рассмотрим самую левую, а если таких несколько, то самую нижнюю среди
таких, точку многоугольника. На рисунке 2 это точка $A$. Теперь в
порядке обхода от точки $A$ будем суммировать ориентированные
площади треугольников, у которых одна вершина общая - точка $A$,
а две другие - вершины $i$ и $i+1$ многоугольника. Прибавлять к общей
площади будем: $$ \\Delta S = \\left\[ OP_{i}, OP_{i+1} \\right\] $$
под квадратными скобками подразумеавем векторное произведение первого
вектора на второй.

Здесь опять в каких-то местах будет суммироваться лишняя площадь, где-то
будет недостаток, но в силу замкнутости фигуры и отсутствия
самопересечений в итоге мы получим площадь нашего
многоугольника.

Распишем, какие площади будут суммироваться на примере:

$$ S = \\Delta ABC + \\Delta ACD - \\Delta ADE + \\Delta AEF $$ Когда мы
прибавили площадь $ACD$, то была прибавлена лишняя площадь, но так как
поворот от $AD$ к $AE$ идет в противоположную сторону (по часовой
стрелке), то эта площадь вычтется. Но вычтется и немного лишнего -
часть треугольника $AEF$, эту его часть уже прибавили на этапе $ACD$, в
итоге выши в ноль. Последним шагом прибалвяем весь треугольник $AEF$.

Надо понимать, что на деле (в коде) у нас будет только прибавление
площадей, но площади ориентированные, вычитание будет делаться
"само по себе".

Несложно заметить, что этот алгоритм тоже линейный. В результате мы
опять, возможно, должны будем взять модуль от полученной площади,
так как знак зависит от порядка обхода.


# Принадлежность точки многоугольнику

## Выпуклый многоугольник

Пусть в многоугольнике $n$ вершин. Рассмотрим алгоритм за $O(\\log n)$.

Рассмотрим самую левую, а из таких самую нижнюю точку многоугольника -
$O$. Если наша точка $P$ лежит левее или ниже нее, то сразу можем
сказать, что она не принадлежит многоугольнику.

Проведем из $O$ диагонали ко всем вершинам многоугольника, получим, что
он разбит на треугольники, одновременно соседние диагонали образуют
последовательные углы. Давайте бинарным поиском найдем угол, в
котором лежит точка $P$. Если бинарный поиск попал в один из
крайних треугольников, то можно проверить руками, лежит ли точка
внутри угла (для этого достаточно рассмотреть три векторных
произведения), если это не так, то возвращаем FALSE.

После того как угол установлен, надо проверить принадлежность нужному
треугольнику. Можно, например, проверить, не лежит ли точка на одной
из сторон этого треугольника, если нет, то проверить принадлежность
точки одновременно любым двум из трех углов треугольника.

## Произвольный многоугольник

Предыдущий способ нельзя применить в данном случае, так как
принадлежность треугольнику не будет означать
принадлежность фигуре (в невыпуклом многоугольнике если
$A$ и $B$ лежат в многоугольнике, то весь отрезок $AB$ может не лежать в
нем целиком). Рассмотрим два способа за $O(n)$.

### Подсчет углов

Мы считаем, что вершины даны в порядке обхода. Будем последовательно
рассматривать углы с вершиной в точке $P$ (для которой определяем
положение) и лучами, проходящими через соседние вершины
многоугольника. Теперь, если просуммировать все эти углы
по порядку (как ориентированные углы), то получится некоторая величина
$\\psi$.

В том случае, если точка лежит внутри многоугольника, $\\psi = \\pm
2\\pi$. Иначе $\\psi = 0$.

### Луч

Если из произвольной точки пустить горизонтальный луч и если этот луч
пересечет многоугольник, то он рано или поздно выйдет из этого
многоугольника. Допустим, луч проходил строго через внутренние
точки каких-то сторон, не задевая вершины. Если посчитать число
пересечений с многоугольником, то для точки, находящейся внутри,
это число будет нечетным ("наружу-внутрь-наружу", 3 пересечения), в
противном случае - четным. Отдельно стоит обработать случай, когда
точка находится на границе.

Но как учесть прохождение через вершины? Во-первых, если луч на каком-то
отрезке пути совпал со стороной многоугольника (то есть она была ему
параллельна и они совпали), то это пересечение можно игнорировать,
такую сторону можно сжать в одну точку и объединить концы ее соседних
сторон.

Для остальных сторон будем рассматривать только нижнюю вершину и
засчитатывать пересечение тольки при прохождении через
внутреннюю точку или через нижнюю вершину.

[500px](Файл:Ray_tracing.png "wikilink")

Заметим, что каждый отрезок рассматривается независимо, поэтому при
прохождении луча через вершину, он пройдет как бы через две вершины
- для одной стороны и для другой.

Посмотрим на пример. Луч, выпущенный из $G$, пройдет через два нижних
конца отрезков - $ID$ и $CD$. То есть число пересечений четное, точка
вне многоугольника.

Луч, выпущенный из $F$ наберет только одно пересечение, так как он
пересекает одну верхнюю и одну нижнюю вершину отрезков. Поэтому
точка внутри многоугольника.

Луч, выпущенный из $J$, проходит через две верхних и две нижних вершины,
засчитывается два пересечения, точка вне многоугольника.

Луч выпущенный из $H$, проходит через два верхних конца, поэтому
засчитывается ноль пересечений, точка вне многоугольника.

Решение удобно реализовывать, работая со списком сторон, при этом нам не
важен порядок их рассмотрения. Решение работает за $O(n)$, так как надо
просмотреть каждый отрезок.


## Идея

Если зафиксировать какую-либо вершину, то относительно нее углы будут
расположены против часовой стрелки или против часовой стрелки, при
этом несложно заметить, что сначала угол к вершине будет
меньше/больше угла к нашей точке, а затем наоборот,
следовательно, мы можем сделать бинпоиск и найти первую вершину
угол от которой больше/меньше нашего.

## Код

``` C++
point zero;//какая-то точка, которую мы сохранили как 0, для того, чтобы определять по или против
//a = vector_angles;
point my = { q.y - zero.y, q.x - zero.x };
auto it = upper_bound (a.begin(), a.end(), my);
if (it == a.end() && my.a == a[n - 1].a && my.b == a[n - 1].b) {
    it = a.end() - 1;
}
if (it != a.end() && it != a.begin()) {
    int p1 = int(it - a.begin());
    if (in(p[p1], p[p1 - 1], q) <= 0) {//проверка то что внутри
    //внутри
    }
}
//нет
```


Пусть у нас есть многоугольник $A_1 A_2 \\ldots A_n$ (не обязательно
выпуклый) и некоторая точка $P$. Мы хотим проверить, лежит ли точка $P$
внутри, на границе или снаружи многоугольника. Для того, чтобы
проверить, что точка $P$ лежит на границе многоугольника
переберем его стороны и для каждого отрезка проверим, лежит ли
точка $P$ на нем. Для того, чтобы проверить, лежит ли точка внутри
или снаружи многоугольника существует $2$ метода.

1.  Посмотрим на следующую сумму углов со знаком:
    $\\sum\\limits_{i=1}^n{\\angle(\\overrightarrow{P A_i},
    \\overrightarrow{P A_{i+1}})}$. Утверждается, что если точка попала
    вовнутрь многоугольника, то эта сумма будет равна $\\pm
    360^{\\circ}$ (при этом знак $-$, если обход многоугольника по
    часовой стрелки, иначе знак $+$). Иначе эта сумма будет равна
    чему-то другому. Этот метод имеет плюс в том, что тут сложно
    запутаться. Минус состоит в том, что вычисление углов может
    быть неточным, из-за чего в крайних случаях метод может работать
    неправильно;
2.  Выпустим произвольный луч из точки $P$. Пока предположим, что ни
    одна вершина на него не попала. Посчитаем количество сторон,
    пересекающих этот луч. Заметим, что если это количество
    нечетное, то точка лежит внутри многоугольника, иначе
    снаружи. Для того, чтобы найти луч, на который не попала ни
    одна из точек, рассмотрим луч выходящий в направлении вектора $(p,
    1)$, где $p$ это любое простое число, большее чем $C$ ---
    максимальная разность координат. На практике обычно можно
    взять $p = 10^9 + 7$.