---
title: Поиск в глубину
weight: 2
---

**Поиском в глубину** (англ. *depth-first search*, **DFS**) называется рекурсивный алгоритм обхода дерева или графа, начинающий в корневой вершине (в случае графа её может быть выбрана произвольная вершина) и рекурсивно обходящий весь граф, посещая каждую вершину ровно один раз.

```cpp
const int maxn = 1e5;
bool used[maxn]; // тут будем отмечать посещенные вершины

void dfs(int v) {
    used[v] = true;
    for (int u : g[v])
        if (!used[u])
            dfs(v);
}
```

Немного его модифицируем, а именно будем сохранять для каждой вершины, в какой момент мы в неё вошли и в какой вышли — соответствующие массивы будем называть $tin$ и $tout$.

Как их заполнить: заведем таймер, отвечающий за «время» на текущем состоянии обхода, и будем инкрементировать его каждый раз, когда заходим в новую вершину:

```cpp
int tin[maxn], tout[maxn];
int t = 0;

void dfs(int v) {
    tin[v] = t++;
    for (int u : g[v])
        if (!used[u])
            dfs(u);
    tout[v] = t; // иногда счетчик тут тоже увеличивают
}
```

У этих массивов много полезных свойств:

- Вершина $u$ является предком $v$ $\iff tin_v \in [tin_u, tout_u)$. Эту проверку можно делать за константу.
- Два полуинтервала — $[tin_v, tout_v)$ и $[tin_u, tout_u)$ — либо не пересекаются, либо один вложен в другой.
- В массиве $tin$ есть все числа из промежутка от 0 до $n-1$, причём у каждой вершины свой номер.
- Размер поддерева вершины $v$ (включая саму вершину) равен $tout_v - tin_v$.
- Если ввести нумерацию вершин, соответствующую $tin$-ам, то индексы любого поддерева всегда будут каким-то промежутком в этой нумерации.

Эти свойства часто бывают полезными в задачах на деревья.



---


Эйлеров обход -- способ представить подвешенное неориентированное дерево
массивом чисел. Существуют несколько способов построить такой обход и
каждый вариант обход имеет свои плюсы и минусы.

## Варианты

1\) Давайте выпишем все рёбра дерева (ориентированные) в порядке DFS'а.
Именно такой подход описан на википедии

2\) Каждая вершина добавляется в массив дважды: когда мы в неё заходим и
когда выходим(то есть когда ставим tin, tout). Каждому листу
соответствует два последовательных вхождения(кроме может
быть одной вершины, подумайте какой).

3\) Каждая вершина добавляется в массив всякий раз, когда мы её посещаем
(когда спускаемся из предка и поднимаемся из потомка).

---

Поиском в глубину (англ. depth-first search, DFS) называется рекурсивный
алгоритм обхода дерева или графа, начинающий в корневой вершине (в
случае графа её может быть выбрана произвольная вершина) Он
рекурсивно обходит весь граф, и посещает каждую вершину ровно
один раз. Посещенные вершины при этом отмечаются в массиве used.

Давайте его немного модифицируем, а именно, давайте сохраним в
какой-нибудь массив, в каком порядке мы посещали вершины. Есть
два способа это сделать - посчитать время входа DFS-а в каждую вершину
и время выхода.

Давайте назовем массивы `tin` и `tout`, где `tin` — время входа, а
`tout` — время выхода из вершины.

Как их заполнить: давайте заведем таймер, отвечающий за время на текущий
момент программы и будем обновлять информацию, когда заходим/выходим из
вершины:

``` C++
int tin[maxn], tout[maxn];
int timer = 0;

void dfs(int v) {
    tin[v] = timer++;
    for (int i = 0; i < g[v].size(); ++i) {
        if (!used[g[v][i]]) {
            dfs(g[v][i]);
        }
    }
    tout[v] = timer++;
}
```

Время входа или выхода пригождается во многих алгоритмах, например, при
[поиске мостов](Поиск_мостов "wikilink"), [поиске точек
сочленения](Поиск_точек_сочленения "wikilink").

---

**Поиском в глубину** (англ. *depth-first search*, **DFS**) называется
рекурсивный алгоритм обхода дерева или графа, начинающий в корневой
вершине (в случае графа её может быть выбрана произвольная вершина) и
рекурсивно обходящий весь граф, посещая каждую вершину ровно один раз.

``` cpp
const int maxn = 1e5;
bool used[maxn]; // тут будем отмечать посещенные вершины

void dfs(int v) {
    used[v] = true;
    for (int u : g[v])
        if (!used[u])
            dfs(v);
}
```

Немного его модифицируем, а именно будем сохранять для каждой вершины, в
какой момент мы в неё вошли и в какой вышли — соответствующие массивы
будем называть \(tin\) и \(tout\).

Как их заполнить: заведем таймер, отвечающий за «время» на текущем
состоянии обхода, и будем инкрементировать его каждый раз, когда
заходим в новую вершину:

``` cpp
int tin[maxn], tout[maxn];
int t = 0;

void dfs(int v) {
    tin[v] = t++;
    for (int u : g[v])
        if (!used[u])
            dfs(u);
    tout[v] = t; // иногда счетчик тут тоже увеличивают
}
```

У этих массивов много полезных свойств:

  - Вершина \(u\) является предком \(v\)
    \(\iff tin_v \in [tin_u, tout_u)\). Эту проверку можно делать за
    константу.
  - Два полуинтервала — \([tin_v, tout_v)\) и \([tin_u, tout_u)\) — либо
    не пересекаются, либо один вложен в другой.
  - В массиве \(tin\) есть все числа из промежутка от 0 до \(n-1\),
    причём у каждой вершины свой номер.
  - Размер поддерева вершины \(v\) (включая саму вершину) равен
    \(tout_v - tin_v\).
  - Если ввести нумерацию вершин, соответствующую \(tin\)-ам, то индексы
    любого поддерева всегда будут каким-то промежутком в этой нумерации.

Эти свойства часто бывают полезными в задачах на деревья.
