---
title: Эйлеров цикл
weight: 5
---

**Определение.** Эйлеров путь — это путь в графе, проходящий через все его рёбра.

**Определение.** Эйлеров цикл — это эйлеров путь, являющийся циклом.

Для простоты в обоих случаях будем считать, что граф неориентированный.

Также существует понятие *гамильтонова* пути и цикла — они посещают все *вершины* по разу, а не рёбра. Нахождение гамильтонова цикла (*задача коммивояжера*, англ. *travelling salesman problem*) — одна из самых известных NP-полных задач, в то время как нахождение эйлерового цика решается за линейное время — и мы сейчас покажем, как.

**Теорема.** Эйлеров цикл существует тогда и только тогда, когда степени всех вершин чётны.

**Доказательство.** Необходимость показывается так: можно просто взять эйлеров цикл и ориентировать все его ребра в порядке обхода. Тогда из каждой вершины будет выходить столько же рёбер, сколько входить, а значит степень у всех вершин исходного неориентированного графа была четной.

Достаточность докажем конструктивно — предъявим алгоритм нахождения.

```c++
const int maxn = 1e5;
set<int> g[maxn];

void euler(int v) {
    while (!g[v].empty()) {
        u = *g[v].begin();
        g[v].erase(g[v].begin());
        dfs(u);
    }
    cout << v <<  " ";
}
```

Если условие на четность степеней вершин выполняется, то этот алгоритм действительно выводит эйлеров цикл, то есть последовательность из $(m+1)$ вершин, между соседними есть связи.



**Следствие.** Эйлеров путь существует тогда и только тогда, когда количество вершин с нечётными степенями не превосходит 2.

Кстати, аналогичная теорема есть и для ориентированного графа (можете сами попытаться сформулировать).

Доказать это можно например через лемму о рукопожатиях.

Как теперь мы будем решать задачу нахождения цикла в предположении, что он точно есть. Давайте запустимся из произвольной вершины, пройдем по любому ребру и удалим его.

```cpp
void euler(int v){
    stack >s;
    s.push({v, -1});
    while (!s.empty()) {
        v = s.top().first;
        int x = s.top().second;
        for (int i = 0; i < g[v].size(); i++){
            pair e = g[v][i];
            if(!u[e.second]){
                u[e.second]=1;
                s.push(e);
                break;
            }
        }
        if (v == s.top().first) {
            if (~x) {
                p.push_back(x);
            }
            s.pop();
        }
    }
}
```

**Упражнение.** Сформулируйте и докажите аналогичные утверждения для случая ориентированного графа.
