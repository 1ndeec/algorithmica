---
title: Компоненты сильной связности
prerequisites:
- topological-sorting
weight: 8
---

Мы только что научились топологически сортировать ациклические графы. А что же делать с циклическими графами? В них тоже иногда требуется найти какую-то структуру.

Для этого можно ввести понятие *сильной связности*.

**Определение.** Две вершины ориентированного графа *связаны сильно* (англ. *strongly connected*), если существует путь из одной в другую и наоборот. Иными словами, они обе лежат в каком-то цикле.

Понятно, что такое отношение транзитивно: если $a$ и $b$ сильно связны, и $b$ и $c$ сильно связны, то $a$ и $c$ тоже сильно связны. Поэтому все вершины распадаются на *компоненты сильной связности* — такое разбиение вершин, что внутри одной компоненты все вершины сильно связаны, а между вершинами разных компонент сильной связности нет.

![](scc.png)

Самый простой пример сильно-связной компоненты — это цикл. Но это может быть и полный граф, или сложное пересечение нескольких циклов.

Часто рассматривают граф, составленный из самих компонент сильной связности, а не индивидуальных вершин. Очевидно, такой граф уже будет ациклическим, и с ним проще работать. Задачу о сжатии каждой компоненты сильной связности в одну вершину называют **конденсацией** графа, и её решение мы сейчас опишем.

Если мы знаем, какие вершины лежат в каждой компоненте сильной связности, то построить граф конденсации несложно: дальше нужно лишь провести некоторые манипуляции со списками смежности. Поэтому сразу сведем исходную задачу к нахождению самих компонент.

**Лемма.** Запустим dfs. Пусть $A$ и $B$ — две различные компоненты сильной связности, и пусть в графе конденсации между ними есть ребро $A \to B$. Тогда:

$$
\max\limits_{a \in A}(tout_a) > \max\limits_{b\in B}(tout_b)
$$

**Доказательство.** Рассмотрим два случая, в зависимости от того, в какую из компонент dfs зайдёт первым.

Пусть первой была достигнута компонента $A$, то есть в какой-то момент времени dfs заходит в некоторую вершину $v$ компоненты $A$, и при этом все остальные вершины компонент $A$ и $B$ ещё не посещены. Но так как по условию в графе конденсаций есть ребро $A \to B$, то из вершины $v$ будет достижима не только вся компонента $A$, но и вся компонента $B$. Это означает, что при запуске из вершины $v$ обход в глубину пройдёт по всем вершинам компонент $A$ и $B$, а, значит, они станут потомками по отношению к $v$ в дереве обхода, и для любой вершины $u \in A \cup B, u \ne v$ будет выполнено $tout_v] > tout_u$, что и утверждалось.

Второй случай проще: из $B$ по условию нельзя дойти до $A$, а значит, если первой была достигнута $B$, то dfs выйдет из всех её вершин ещё до того, как войти в $A$. 

Из этого факта следует первая часть решения. Отсортируем вершины по убыванию времени выхода (как бы сделаем топологическую сортировку, но на циклическом графе). Рассмотрим компоненту сильной связности первой вершины в сортировке. В эту компоненту точно не входят никакие рёбра из других компонент — иначе нарушилось бы условие леммы, ведь у первой вершины $tout$ максимальный . Поэтому, если развернуть все рёбра в графе, то из этой вершины будет достижима своя компонента сильной связности $C^\prime$, и больше ничего — если в исходном графе не было рёбер **из** других компонент, то в транспонированном не будет ребер **в** другие компоненты.

После того, как мы сделали это с первой вершиной, мы можем пойти по топологически отсортированному списку дальше и делать то же самое с вершинами, для которых компоненту связности мы ещё не отметили.

```cpp
vector<int> g[maxn], t[maxn];
vector<int> order;
bool used[maxn];
int component[maxn];
int cnt_components = 0;

// топологическая сортировка
void dfs1(int v) {
    used[v] = true;
    for (int u : g[v]) {
        if (!used[u]) 
            dfs1(u);
    order.push_back(v);
}

// маркировка компонент сильной связности
void dfs2(int v) {
    component[v] = cnt_components;
    for (int u : t[v])
        if (cnt_components[u] == 0)
            dfs2(u);
}


// в содержательной части main:

// транспонируем граф
for (int v = 0; v < n; v++)
    for (int u : g[v])
        t[u].push_back(v);

// запускаем топологическую сортировку
for (int i = 0; i < n; i++)
    if (!used[i])
        dfs1(i);

// выделяем компоненты
reverse(order.begin(), order.end());
for (int v : order)
    if (component[v] == 0)
        dfs2(v);
```

TL;DR:

1. Сортируем вершины в порядке убывания времени выхода.

2. Проходимся по массиву вершин в этом порядке, и для ещё непомеченных вершин запускаем dfs на транспонированном графе, помечающий все достижимые вершины номером новой компонентой связности.

После этого номера компонент связности будут топологически отсортированы.

---

## Задача

Дан ориентированный граф $G$, множество вершин которого $V$ и множество
рёбер — $E$. Конденсацией назовем сжатие каждой компоненты сильной
связности в одну вершину. Каждой вершине графа конденсации
соответствует компонента сильной связности графа $G$, а
ориентированное ребро между двумя вершинами $C_i$ и $C_j$
графа конденсации проводится, если найдётся пара вершин $u \\in
C_i, v \\in C_j$, между которыми существовало ребро в исходном графе,
т.е. $(u,v) \\in E$.

Необходимо найти, какие вершины лежат в каждой компоненте сильной
связности и построить граф конденсации.

## Теорема

Запустим DFS. Пусть $C$ и $C^\\prime$ — две различные компоненты сильной
связности, и пусть в графе конденсации между ними есть ребро
$(C,C^\\prime)$. Тогда $\\max\\limits_{c\\in C}(\\space{\\rm
tout}\[c\]) \> \\max\\limits_{c^\\prime\\in C^\\prime}({\\rm
tout}\[c^\\prime\])$.

При доказательстве возникают два принципиально различных случая в
зависимости от того, в какую из компонент первой зайдёт обход в
глубину:

Первой была достигнута компонента $C$. Это означает, что в какой-то
момент времени обход в глубину заходит в некоторую вершину $v$
компоненты $C$, при этом все остальные вершины компонент $C$ и
$C^\\prime$ ещё не посещены. Но, т.к. по условию в графе конденсаций
есть ребро $(C,C^\\prime)$, то из вершины $v$ будет достижима не
только вся компонента $C$, но и вся компонента $C^\\prime$. Это
означает, что при запуске из вершины $v$ обход в глубину пройдёт по
всем вершинам компонент $C$ и $C^\\prime$, а, значит, они станут
потомками по отношению к $v$ в дереве обхода в глубину, т.е. для
любой вершины $u \\in C \\cup C^\\prime, u \\ne v$ будет выполнено
${\\rm tout}\[v\] \> {\\rm tout}\[u\]$, ч.т.д.

Обратный случай рассматривается проще, из $C^\\prime$ нельзя добраться
до $C$, а следовательно доказано.

## Алгоритм

Из этого и следует первая часть решения - давайте отсортируем вершины по
убыванию времени выхода (будто топсорт, но на циклическом графе).
Рассмотрим компоненту сильной связности первой вершины, назовем
ее $C^\\prime$. В эту компоненту точно нет никаких рёбер из других
компонент (иначе $\\max\\limits_{c\\in C}(\\space{\\rm tout}\[c\])
\> \\max\\limits_{c^\\prime\\in C^\\prime}({\\rm tout}\[c^\\prime\])$,
а первая вершина - это вообще-то максимум времени выхода). Поэтому если
мы развернем все ребра, то из этой вершины все еще будет достижима своя
компонента сильной связности $C^\\prime$, и больше точно ничего - если
раньше не было ребер из других компонент, то после разворота ребер не
стало ребер в другие компоненты.

Так что второй шаг такой - разворачиваем ребра, запускаем DFS в таком
порядке, ищем компоненты связности как в обычном графе. Попутно можно
строить и граф конденсации.

## Реализация

``` C++ numberLines
vector<int> g[N], gr[N];
bool used[N];
vector<int> order, component;

void dfs1(int v) {
    used[v] = true;
    for (int i = 0; i < g[v].size(); i++) {
        if (!used[g[v][i]]) {
            dfs1(g[v][i]);
        }
    }
    order.push_back (v);
}

void dfs2(int v) {
    used[v] = true;
    component.push_back(v);
    for (int i = 0; i < gr[v].size(); i++) {
        if (!used[gr[v][i]]) {
            dfs2(gr[v][i]);
        }
    }
}

int main() {
    for (;;) {
        g[a].push_back(b);
        gr[b].push_back(a);
    }
    for (int i = 0; i < n; i++){
        if (!used[i]) {
            dfs1(i);
        }
    }
    for (int i = 0; i < n; i++) {
        used[i] = 0;
    }
    reverse(order.begin(), order.end());
    for (int i = 0; i < n; i++) {
        int v = order[i];
        if (!used[v]) {
            dfs2 (v);
        }
    }
}
```

## Оценка времени работы

Так как мы честно посмотрим все ребра и вершины в DFS, то время работы
программы будет - $O(N + M)$

---

## Компоненты сильной связности

Мы только что научились топологически сортировать ациклические графы. А
что же делать с циклическими графами? Ведь в них тоже хочется найти
какую-то структуру.

Для этого обычно вводят такое понятие как "сильная связность". В
ориентированных графах две вершины связаны сильно, если
существует путь из одной в другую и наоборот. Проще говоря, они
обе лежат на каком-то цикле.

Понятно, что такое отношение транзитивно: если А и B сильно связны, и B
и C сильно связны, то A и C тоже сильно связны. Поэтому все вершины
распадаются на такие компоненты сильной связности - такое разбиение
вершин, что внутри одной компоненты все вершины сильно связаны, а между
вершинами разных компонент сильно связности нет.

<https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Graph_Condensation.svg/640px-Graph_Condensation.svg.png>

Самый простой пример сильно-связной компоненты - это цикл. Но это может
быть и полный граф, и любое сложное пересечение нескольких циклов.

Часто рассматривают граф самих компонент сильной связности. На картинке
выше их шесть, и между ними остаются ребра из изначально графа.
Очевидно, что такой граф уже будет ациклическим: иначе
компоненты на цикле нужно было бы объединить в одну.