---
title: Динамика по префикам и подотрезкам
---

Пусть, дана последовательность $a_1,\\ldots,a_n$, с максимальным
значением $A$. Требуется найти длину наибольшей такой
подпоследовательности, что ее элементы отличаются на более,
чем на 1. Воспользуемся динамическим программированием, где $dp\[j\]$
будет обозначать ответ с последним взятым элементом, равным $j$.
Будем обновлять и хранить актуалььным весь массив $dp$ целиком,
проходясь по массиву $a$ слева направо.

Соответственно для каждого $i$ переходы можно делать только из таких
$j$, что $|a\[i\]-j|\\leq 1$.

``` C++ numberLines
for (int i = 1; i <= n; I++) {
    dp[a[i]] += 1
    if (a[i] > 0) {
        dp[a[i]] = max(dp[a[i]], dp[a[i] - 1] + 1);
    }
    if (a[i] < A) {
        dp[a[i]] = max(dp[a[i]], dp[a[i] + 1] + 1);
    }
}
```

Это решение за $O(n + A)$.

Заметим, что вот эти две идеи встречаются в задачах наиболее часто:

  - хранить в $dp\[i\]$ ответ для $i$-ого префикса. Как в рюкзаке (где
    можно пользоваться $i$ первыми предметами), НВП(где ответ на
    префиксе длины $i$) и НОП (где ответ для префиксов длины $i$ и
    $j$).
  - хранить в $dp\[i\]$ ответ для последовательностей, заканчивающихся
    на $i$.
  
---

## Одномерная динамика: кузнечик

Рассмотрим такую задачу:

Есть полоска $1\\times N$, кузнечик стоит на первой клетке, он может
прыгать вперед на 1, 2, 3 клетки. Сколько есть способов добраться от
начальной клетки до последней?

Как решать такие задачи? Нужно придумать рекуррентную формулу, как ответ
для N зависит от ответа для меньших чисел.

Очень помогает посмотреть на маленькие числа (\!\! одна из самых важных
идей для придумывания решений):

Пусть dp\[x\] - это количество способов добраться от 1 клетки до клетки
номер x.

  - dp\[1\] = 1 способ (стоять на месте)
  - dp\[2\] = 1 способ ($1 \\rightarrow 2$)
  - dp\[3\] = 2 способа ($1 \\rightarrow 2 \\rightarrow 3$ и $1
    \\rightarrow 3$)
  - dp\[4\] = 4 способа ($1 \\rightarrow 2 \\rightarrow 3 \\rightarrow
    4$ и $1 \\rightarrow 3 \\rightarrow 4$ и $1 \\rightarrow 2
    \\rightarrow 4$ и $1 \\rightarrow 4$)
  - dp\[5\] = 7 способов ($1 \\rightarrow 2 \\rightarrow 3 \\rightarrow
    4 \\rightarrow 5$ и $1 \\rightarrow 3 \\rightarrow 4 \\rightarrow 5$
    и $1 \\rightarrow 2 \\rightarrow 4 \\rightarrow 5$ и $1 \\rightarrow
    4 \\rightarrow 5$ и $1 \\rightarrow 2 \\rightarrow 3 \\rightarrow 5$
    и $1 \\rightarrow 3 \\rightarrow 5$ и $1 \\rightarrow 2 \\rightarrow
    5$)

Дальше становится сложнее. Но можно заметить закономерность. А можно и
не заметить, но зато если мы сейчас придумаем формулу, мы легко
проверим, работает ли она. Заодно мы получили наши значения на
маленьких числах, которые нам все равно понадобится вбить в
программу.

Какой последний прыжок кузнечика в его пути до N-й клетки? Один из трех
вариантов:

  - $(N - 1) \\rightarrow N$
  - $(N - 2) \\rightarrow N$
  - $(N - 3) \\rightarrow N$

То есть все пути до $N$ разбиваются на 3 группы. Причем мы знаем сколько
путей в каждой группе. В первой из них ровно dp\[N - 1\] путей - столько
путей идут до (N-1)-й клетки, и дальше идет еще один прыжок. Во второй и
третьей группах поэтому тоже dp\[N - 2\] и dp\[N-3\] путей.

Так что формула получается такой: dp\[N\] = dp\[N - 3\] + dp\[N - 2\] +
dp\[N - 1\].

Очень похоже на числа Фибоначчи, да?

``` C++ numberLines
dp[1] = 1
dp[2] = 1
dp[3] = 2
for (int i = 4; i <= N; i++) {
    dp[i] = dp[i - 3] + dp[i - 2] + dp[i - 1];
}
```

Давайте изменим немного задачу: Теперь некоторые из клеток закрыты. То
есть нам известно про конкретные клетки, что на них кузнечик прыгать
не может. Тогда задача все еще решается так же, только нужно
убедиться, что dp\[x\] = 0 для всех запрещенных x\!

Также немного перепишем код, чтобы не писать отдельно случаи для 2 и 3,
а также чтобы не писать в формуле сумму трех чисел (а представьте, что
в задаче не 3, а 100). Будем инициализировать только dp\[1\]. А ко всем
следующим значениям dp\[i\] будет прибавлять dp\[i - k\], где k = 1, 2,
3. Причем, если i - k \< 1, то мы будем игнорировать такие клетки, и
этим самым мы избавились от необходимости прописывать ответ для
dp\[2\] и dp\[3\].

``` C++ numberLines
if (can[1]) {
    dp[1] = 1;
}
for (int i = 2; i <= N; i++) {
    if (can(i)) {
        for (int k = 1; k <= 3; k++) {
            if (i - k >= 1) {
                dp[i] += dp[i - k];
            }
        }
    }
}
```

## Последовательности без 3 единиц подряд

### Условие:

Определите количество последовательностей из нулей и единиц длины $N$, в
которых никакие три единицы не стоят рядом.

### Решение:

Давайте хранить в $dp\[N\]$ ровно число таких последовательностей длины
$N$ (это первое, что должно приходить в голову).

Давайте посмотрим для начала для маленьких чисел:

  - $dp\[0\] = 1 (\\text{пустая последовательность})$
  - $dp\[1\] = 2 (0, 1)$
  - $dp\[2\] = 4 (00, 01, 10, 11)$
  - $dp\[3\] = 7 (000, 001, 010, 011, 100, 101, 110)$
  - $dp\[4\] = 13 (0000, 0001, 0010, 0011, 0100, 0101, 0110, 1000, 1001,
    1010, 1011, 1100, 1101)$

Сходу закономерность можно не увидеть. Нужно догадаться сгруппировать
эти числа по том, сколько в конце единичек. Например, для dp\[4\]:

  - 0 единичек в конце: $0000, 0010, 0100, 0110, 1000, 1010, 1100$ - их
    ровно семь, как для $N=3$, потому что первые 3 числа могут быть
    любые (но без трех единиц подряд), а четвертое - 0
  - 1 единичка в конце: $0001, 0101, 1001, 1101$ - их ровно четыре, как
    для $N=2$, потому что первые 2 числа могут быть любые (но без 3
    единиц подряд), а два последних - 01
  - 2 единички в конце: $0011, 1011$ - их ровно две, как для $N=1$,
    потому что первое число может быть любым (но без 3 единиц
    подряд), а три последних - 011

Так мы замечаем и доказываем формулу: $dp\[N\] = dp\[N-1\] + dp\[N-2\] +
dp\[N-3\]$

Теперь за $O(N)$ ее легко посчитать.

---

Эта статья дает базовое представление об идее динамического
программирования.

### Кузнечик

Рассмотрим такую задачу: на прямой сидит кузнечик в точке $x = 0$, он
умеет прыгать только вперед, причем только на расстояния $1$, $2$ или
$3$. В каждой целой точке $i$ лежит $c_i$ монет. Кузнечику надо
допрыгать до точки $x_f$, собрав как можно больше монет.

Посмотрим, откуда мог припрыгать кузнечик в точку $x_f$. Это либо $x_f
- 1$, $x_f - 2$ либо $x_f - 3$. Допустим, мы как-то можем узнать
оптимальный ответ, когда кузнечику надо дойти до каждой из этих
точек. Назовем их $d_{1}, d_{2}, d_{3}$ соответственно. Это
максимальное число монет, которое кузнечик может собрать на пути
до каждой из точек. Тогда ответ для точки $x_f$ - это просто максимум
из трех величин $d_1 + c_{x_f}$, $d_2 + c_{x_f}$, $d_3 +
c_{x_f}$.

Задачу поиска оптимального ответа для $x_f$ свели к поиску ответа для
меньших координат, то есть мы научились решать задачу, на основе
каких-то ее подзадач. В этом и состоит основная идея динамического
программирования.

Обыкновенно в задачах на ДП используют следующие термины:

  - Состояние динамики - подзадачи, к которым мы можем свести исходную
    задачу;
  - Переход - правило пересчета, то есть способ вычислить ответ на
    задачу с помощью ответов на подзадачи;
  - База динамики - набор тривиальных состояний и значений для них.
    Например, в задаче про кузнечика ясно, что он может собрать $0$
    монет по пути к точке $0$ (то есть не перемещаясь).

В простейших случаях ответы для состояний записывают в обычный массив.
Например, решение задачи про кузнечика будет выглядеть так:

``` C++ numberLines
vector<int> dp(n, 0);
for (int i = 1; i < n; i++) {
    for (int j = max(0, i - 3); j < i; j++) {
        dp[i] = max(dp[i], dp[j] + c[i]);
    }
}
cout << dp[n-1];
```

Так исторически сложилось, что чаще всего массив, где хранят значения
динамики называют $dp$.

### Общий план решения задачи на ДП

  - Сформулировать, что будет значить состояние. Пример $dp\[i\]$ -
    максимальное число монет, которое можно собрать, дойдя до $i$;
  - Определить формулу (формулы) пересчета динамики;
  - Определить <strong>порядок</strong>, в котором будут считаться
    состояния динамики. Например, в данном случае нам надо было
    перебирать $i$ от $0$ до $n-1$, но в других задачах (например, в
    \[двумерной динамике | Двумерная динамика\]) этот порядок может быть
    менее тривиальным.
  - Задать значения для тривиальных состояний;
  - Понять, какое состояние соответствует ответу на всю задачу.

### Восстановление ответа

Часто в задачах надо не только найти наибольшее или наименьшее значение
чего-либо, но и сказать, как его получить. В задаче про кузнечика надо
восстановить последовательность точек, по которым пропрыгает кузнечик.
Рассмотрим два способа:

<strong>Запоминание ответа</strong>

Запомним в отдельный массив ту клетку, из который оптимальнее всего
прыгнуть в текущую. Делаем это непосредственно при подсчете
динамики. Массив $prev$ содержит лучшего предка.

``` C++ numberLines
vector<int> dp(n, 0);
for (int i = 1; i < n; i++) {
    for (int j = max(0, i - 3): j < i; j++) {
        if (dp[i] < dp[j] + c[i]) {
            prev[i] = j;
            dp[i] = dp[j] + c[i];
        }
    }
}
```

Затем надо пройтись от точки $n-1$ до нуля по построенному пути:

``` C++ numberLines
vector<int> path;
int cur = n - 1;
while (cur >= 0) {
    path.push_back(cur);
    cur = prev[cur];
}
```

<em>Вопросы для внимательного читателя:</em>

А теперь поймите, что такой код может уйти в бесконечный цикл. Как надо
проинициализировать массив $prev$, чтобы избежать этого? В каком
порядке будут идти точки в массиве $path$?

<strong>Повторный проход</strong>

Пусть мы уже посчитали массив динамики. Давайте пройдемся от последней
точки к первой и будем по имеющимся значениям состояний определять,
откуда мы пришли.

``` C++ numberLines
vector<int> path;
int cur = n - 1;
while (cur >= 0) {
    path.push_back(cur);
    if (cur >= 1 && dp[cur] == dp[cur - 1] + c[cur]) {
        cur = cur - 1;
    } else if (cur >= 2 && dp[cur] == dp[cur - 2] + c[cur]) {
        cur = cur - 2;
    } else if (cur >= 3 && dp[cur] == dp[cur - 3] + c[cur]) {
        cur = cur - 3;
    }
}
```

Плюс такого подхода в том, что не надо занимать лишнюю память для
хранения предков для каждого состояния.

### За сколько все работает

Значения динамики считаются в данном случае за один проход по массиву,
ответ тоже можно восстановить за один проход, поэтому расход времени и
памяти составит $O(n)$.
