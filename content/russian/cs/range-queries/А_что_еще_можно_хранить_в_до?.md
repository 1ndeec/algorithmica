## Задача

А подходит ли [Дерево отрезков](Дерево_отрезков "wikilink") для каких-то
более интересных запросов? Давайте решать следующую задачу :

Дан массив $a$ длины $n$, поступают запросы двух видов :

1\) Найти количество чисел $\\le x$ на отрезке с $l$ по $r$.

## Идея

Давайте хранить внутри каждой вершины дерева отрезков отсортированный
массив, построить такое до несложно, например можно это сделать как в
merge-sort, рекурсивно сортируя массив в левой половине и правой
половине, а затем делая merge двух массив.

``` c++ numberLines
vector<int> t[MAXN * 4];
int a[MAXN];

void build(int v, int l, int r) {
    if (l + 1 == r) {
        t[v].push_back(a[l]);
        return;
    }
    int m = (l + r) / 2;
    build(2 * v, l, m);
    build(2 * v + 1, m, r);
    t[v] = merge(t[2 * v], t[2 * v + 1]);
}
```

Тогда ответ на запрос - просто в каждой вершине отрезка сделаем бинпоиск
по значению $x$ и сложим значения на всех вершинах до внутри отрезка :

``` c++ numberLines

int get(int v, int l, int r, int ql, int qr, int x) {
    if (ql >= r || l >= qr) {
        return 0;
    }
    if (ql <= l && qr <= r) {
        return upper_bound(t[v].begin(), t[v].end(), x) - t[v].begin();
    }
    int m = (l + r) / 2;
    return get(2 * v, l, m, ql, qr, x) + get(2 * v + 1, m, r, ql, qr, x));
}
```

## Асимптотика

Каждый элемент встречается в $O(h)$ количестве вершин дерева отрезков,
то есть по памяти наше решение работает за $O(n \\log(n))$, по времени
оно работает за $O(m \\log^2(n))$, так как в каждой вершине до мы делаем
бинпоиск за $O(\\log(n))$, в каждом запросе мы посещаем $\\log(n)$
вершин ДО.

## Дополнительно

К данной идеи можно применить и запросы изменения в точке, более того
можно решать класс более сложных задач : Например запрос медианы
отрезка.