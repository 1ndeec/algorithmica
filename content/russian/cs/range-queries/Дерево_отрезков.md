#### Задача

Нам дан массив $a_0,\\ a_1,\\ \\ldots,\\ a_{n - 1}$. Требуется
обрабатывать два типа запросов:

  - Присвоить $a_x$ значение $k$ ($a_x\\ :=\\ k$).
  - Узнать сумму элементов $a_l,\\ a_{l + 1},\\ \\ldots,\\ a_{r}$.

Мы хотим, чтобы каждый запрос обрабатывался за $O(\\log n)$.

<i>Замечание.</i> Если запросов обновления нет, то данная задача
решается с помощью [префиксных
сумм](Префиксные_суммы "wikilink").

#### Идея

Нам понадобится хранить сумму на некоторых подотрезках, а потом
склеивать их при ответе на запрос. Сделаем с исходным массивом
следующие манипуляции:

  - Посчитаем сумму всего массива и где-нибудь запишем.
  - Разделим его пополам, посчитаем сумму на половинах и тоже где-нибудь
    запишем.
  - Каждую половину потом разделим пополам ещё раз, и так далее, пока не
    придём к отрезкам длины 1.

Пусть мы проделали такую операцию. Тогда мы можем представить наши
вычисления в виде дерева с соответствующей структурой:
<img src="http://i.imgur.com/GGBmcEP.png">

Такое дерево имеет высоту $O(\\log n)$, при этом каждая его вершина
хранит сумму на каком-то подотрезке массива. Ровно эту структуру
данных мы и будем называть <i>деревом отрезков</i>.

#### Построение

Мы еще не сказали, как быстро посчитать значения сумм для всех вершин.
Строить будем такой рекурсивной процедурой:

  - Смотрим на текущие параметры $\[l,\\ r)$ вершины (иначе говоря,
    границы ее отрезка).
  - Если $r\\ -\\ l\\ =\\ 1$, то вершина отвечает ровно за 1 элемент, и
    сумма считается тривиально.
  - Иначе мы разбиваем отрезок на два: $m\\ := \\lfloor\\frac{l +
    r}{2}\\rfloor;\\ \[l,\\ r)\\ \\rightarrow\\ \[l,\\ m),\\ \[m,\\ r)$.
    Выполним процедуру рекурсивно для новых отрезков (назвав новые две
    вершины <i>детьми</i> текущей, а потом сохраним $sum_{\[l,\\
    r)}\\ =\\ sum_{\[l,\\ m)}\\ +\\ sum_{\[m,\\ r)}$ в своей вершине.

Сохранять все вершины будем в массив, поддерживая такую нумерацию:

  - Если вершина --- корень, то у нее номер 1.
  - Если у вершины с номером $v$ есть левый и правый ребенок, то их
    номера — $2 \\cdot v$ и $2 \\cdot v + 1$.

#### Запрос суммы

Проведем следующую операцию:

  - Запомним параметры $\[l_q,\\ r_q)$ запроса.
  - Посмотрим на текущую вершину (изначально — корень дерева). Если ее
    отрезок не пересекается с отрезком запроса, то все вершины в ее
    поддереве нам тоже неинтересны, поэтому можно не рассматривать
    эту вершину.
  - Если отрезок нашей вершины вложен в отрезок запроса, то мы можем
    прибавить посчитанное в вершине значение суммы к ответу.
  - Если отрезок нашей вершины пересекается с отрезком запроса, то
    рекурсивно проведем операцию в наших потомках.

Очевидно, что таким образом мы действительно посчитаем сумму на всем
отрезке.

#### Запрос обновления элемента

Для обновления одного элемента надо спуститься к нему по дереву,
изменить значение в листе, а потом заново пересчитать все
значения в вершинах на пути до корня. Аналогично, это работает за
$O(\\log n)$.

``` c++ numberLines
int t[MAXN * 4];
int a[MAXN];

void build(int v, int l, int r) {
    if (l + 1 == r) {
        t[v] = a[l];
        return;
    }
    int m = (l + r) / 2;
    build(2 * v, l, m);
    build(2 * v + 1, m, r);
    t[v] = t[2 * v] + t[2 * v + 1];
}

void upd(int v, int l, int r, int pos, int x) {
    if (l + 1 == r) {
        t[v] = x;
        return;
    }
    int m = (l + r) / 2;
    if (pos < m) {
        upd(2 * v, l, m, pos, x);
    }
    else {
        upd(2 * v + 1, m, r, pos, x);
    }
    t[v] = t[2 * v] + t[2 * v + 1];
}

int get(int v, int l, int r, int ql, int qr) {
    if (ql >= r || l >= qr) {
        return NEUTRAL;
    }
    if (ql <= l && qr <= r) {
        return t[v];
    }
    int m = (l + r) / 2;
    return get(2 * v, l, m, ql, qr) + get(2 * v + 1, m, r, ql, qr));
}
```

#### Массовые операции

Мы уже решили исходную задачу, поэтому давайте просто дополним статью
еще несколькими трюками. Если в задаче нам требуется делать какую-то
операцию на отрезке (например, присвоить всем элементам значение $x$),
то мы будем находить соответствующие запросу изменения вершины, и в них
пользоваться техникой [отложенных
операций](Отложенные_операции "wikilink").

## Также может быть интересно

[А что еще можно хранить в
до?](А_что_еще_можно_хранить_в_до? "wikilink")

[Категория:Структуры данных для запросов на
отрезке](Категория:Структуры_данных_для_запросов_на_отрезке "wikilink")
[Категория:Конспект](Категория:Конспект "wikilink")