---
title: Дерево Ли Чао
---

Дерево Li Chao --- это структура данных, умеющая обрабатывать два вида
запросов:

  - Добавить линейную функцию $f(x) = ax + b$ в множество $X$.
  - Найти максимальное значение $f(x)$ по всем $f \\in X$ при заданном
    $x$.

#### Структура дерева

Построим дерево, аналогичное [дереву
отрезков](дерево_отрезков "wikilink"), над всем
множеством координат (если координаты вещественные, то над всем
множеством с определенной точностью). В каждой вершине дерева
будем хранить какую-то линейную функцию (изначально нейтральную).

Определим $get$-запросы для координаты $x$ над деревом таким образом:

  - Сделаем спуск по дереву к листу, соответствующему координате $x$
  - Выпишем все посещенные вершины
  - Возьмем максимум среди всех этих функций

Теперь придумаем такие $add$-запросы, что после их выполнения $get$
корректен:

  - Пусть мы хотим добавить функцию $f$
  - Рассмотрим вершину $v$ такую, что <i>вне отрезка</i> $\[l, r\]$,
    соответствующему вершине $v$, $f$ никогда не бывает
    максимальной.
  - Посмотрим на среднюю точку для этого отрезка $m = \\frac{l + r}{2}$
    и на функцию $g$, записанную в $v$.
  - Если $f(m) \> g(m)$, то поменяем $f, g$ местами.
  - Заметим, что теперь функция $f$ может быть максимальной <b>либо</b>
    на $\[l, m - 1\]$, <b>либо</b> на $\[m + 1, r\]$ (если переменные
    вещественные, то $m \\pm \\epsilon$)
  - Рекурсивно решим задачу в соответствующем поддереве

#### Реализация

Очень часто данное дерево надо реализовывать в [неявном
виде](динамические_структуры_данных "wikilink").

``` c++ numberLines

struct line {
    int k = 0, m = 0;
    line() {}
    line(int k, int m): k(k), m(m) {}
    int get(int x) {
        return k * x + m;
    }
};

line t[4 * MAXN];

void upd(int v, int tl, int tr, line L) {
    if (tl > tr) {
        return;
    }
    int tm = (tl + tr) / 2;
    bool l = L.get(tl) > t[v].get(tl);
    bool mid = L.get(tm) > t[v].get(tm);
    if (mid) {
        swap(L, t[v]);
    }
    if (l != mid) {
        upd(2 * v, tl, tm - 1, L);
    }
    else {
        upd(2 * v + 1, tm + 1, tr, L);
    }
}

int get(int v, int tl, int tr, int x) {
    if (tl > tr) {
        return 0;
    }
    int tm = (tl + tr) / 2;
    if (x == tm) {
        return t[v].get(x);
    }
    if (x < tm) {
        return max(t[v].get(x), get(2 * v, tl, tm - 1, x));
    }
    else {
        return max(t[v].get(x), get(2 * v + 1, tm + 1, tr, x));
    }
}
```

[Категория:Конспект](Категория:Конспект "wikilink")
[Категория:Оптимизации
динамики](Категория:Оптимизации_динамики "wikilink")