Очень часто при решении задач на [дерево
отрезков](дерево_отрезков "wikilink"), [декартово
дерево](декартово_дерево "wikilink"), [корневую
декомпозицию](Корневая_декомпозиция "wikilink")
требуется применять операцию изменения не к одному элементу массива,
а к подотрезку.

<i>Замечание.</i> Считается, что мы умеем применять эту операцию к
одному элементу массива, и что мы умеем применять ее "по частям"
(к разным подотрезкам массива по очереди).

#### Push-величины

Применим следующий трюк: если нам нужно обновить значение подотрезка, то
мы отложим эту операцию ~~до востребования~~. Запомним в соответствующих
вершине/блоке, что мы должны в будущем сделать обновление в потомков.
Если нам вдруг понадобится значение, лежащее в вершине/блоке, то мы
посчитаем его так, как будто мы обновили отрезок, а напоминание о том,
что надо сделать со всеми элементами, мы "протолкнем" в потомков (отсюда
и название push).

#### Реализация

Приведем тут несколько мыслей и реализацию для [дерева
отрезков](дерево_отрезков "wikilink").

  - Вызывать push надо каждый раз, когда мы обращаемся к вершине, если
    между обращениями к ней могло примениться обновление
  - push-пометки надо не забывать очищать
  - если мы снимаем push-пометку с единичного элемента, то мы про нее
    можем забыть

В данной реализации мы делаем присвоение на отрезке и получение значения
в точке.

``` c++ numberLines
struct segtree {
    int val = 0;
    int push = -1;
};

segtree t[4 * MAXN];

void push(int v, int tl, int tr) {
    if (t[v].push == -1) {
        return;
    }
    if (tl + 1 == tr) {
        t[v].val = t[v].push;
    }
    else {
        t[2 * v].push = t[v].push;
        t[2 * v + 1].push = t[v].push;
    }
    t[v].push = -1;
}

inline void upd(int v, int tl, int tr, int l, int r, int x) {
    push(v, tl, tr);
    if (tl >= r || l >= tr) {
        return;
    }
    if (l <= tl && tr <= r) {
        t[v].push = x;
        push(v, tl, tr);
        return;
    }
    int tm = (tl + tr) / 2;
    upd(2 * v, tl, tm, l, r, x);
    upd(2 * v + 1, tm, tr, l, r, x);
}

inline int get(int v, int tl, int tr, int pos) {
    push(v, tl, tr);
    if (tl + 1 == tr) {
        return t[v].val;
    }
    int tm = (tl + tr) / 2;
    if (pos <= tm) {
        return get(2 * v, tl, tm, pos);
    }
    else {
        return get(2 * v + 1, tm, tr, pos);
    }
}
```

##### [Альтернативная реализация Дерева Отрезков с отложенными операциями](Альтернативная_реализация_Дерева_Отрезков_с_отложенными_операциями "wikilink")

[Категория:Структуры данных для запросов на
отрезке](Категория:Структуры_данных_для_запросов_на_отрезке "wikilink")
[Категория:Конспект](Категория:Конспект "wikilink")