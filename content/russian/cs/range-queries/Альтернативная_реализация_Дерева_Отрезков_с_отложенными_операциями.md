``` c++ numberLines
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

const int INF = 1e9 + 5;
const int MAXN = 1e5 + 5;

struct node {
    ll min; // минимум в вершине БЕЗ учета отложенной операции
    ll add; // отложенная операция (сколько нужно прибавить на отрезке)
};

// 0 - корень, левый сын - v * 2 + 1, правый - v * 2 + 2
node t[MAXN * 4];

// получает значение в вершине v с учетом отложенной операции
ll get(int v) {
    return t[v].min + t[v].add;
}

// "проталкивает" отложенную операцию в детей и обновляет минимум в вершине
void push(int v) {
    // так как прибавить 0 = ничего не делать, то тут можно не писать дополнительную проверку на то,
    // что отложенной операции нет, но надо иметь в виду, что в некоторых задачах такая проверка необходима

    // Минимум в вершине, увеличится ровно на то, что нужно прибавить
    // (так как прибавляем ко всем числам на отрезке)
    t[v].min += t[v].add;

    // В детях это изменение еще не учтено, пропушим его в них
    t[v * 2 + 1].add += t[v].add;
    t[v * 2 + 2].add += t[v].add;

    // После применения отложенной операции, занулим t[v].add, чтобы позже не прибавить еще раз
    t[v].add = 0;
}

// Прибавить x на отрезке
// v - вершина
// [tl, tr) - отрезок вершины ДО (правая граница не включается)
// [l, r) - отрезок запроса (правая граница не включается)
// x - то, что хотим прибавить на отрезке
void update(int v, int tl, int tr, int l, int r, int x) {
    // вершина дерева вообще не попадает в отрезок запроса, ничего не делаем
    if (r <= tl || tr <= l) return;

    // вершина дерева полностью попадает в отрезок запроса
    if (l <= tl && tr <= r) {
        // скажем, что когда-нибудь потом в этой вершине нужно будет прибавить x
        t[v].add += x;
        return;
    }

    // если мы попали сюда, значит вершина дерева пересекается с отрезком запроса, и нужно спускаться в детей.
    // но возможно, в текущей вершине есть отложенная операция, которую нужно применить к детям, поэтому вызовем push
    push(v);

    // спускаемся в детей
    int tm = tl + (tr - tl) / 2;
    update(v * 2 + 1, tl, tm, l, r, x);
    update(v * 2 + 2, tm, tr, l, r, x);

    // в нашей вершине точно нет отложенной операции, потому что выше вызвали push, поэтому можно просто
    // пересчитать min из детей. Так как в детях могут быть отложенные операции, то получим значения в них, используя get
    t[v].min = min(get(v * 2 + 1), get(v * 2 + 2));
}

// Получить минимум на отрезке
// v - вершина
// [tl, tr) - отрезок вершины ДО (правая граница не включается)
// [l, r) - отрезок запроса (правая граница не включается)
ll get(int v, int tl, int tr, int l, int r) {
    // вершина дерева вообще не попадает в отрезок запроса, ничего не делаем
    if (r <= tl || tr <= l) {
        return INF;
    }

    // вершина дерева полностью попадает в отрезок запроса
    if (l <= tl && tr <= r) {
        // вернем минимум с учетом отложенной операции
        return get(v);
    }

    // если мы попали сюда, значит вершина дерева пересекается с отрезком запроса, и нужно спускаться в детей.
    // но возможно, в текущей вершине есть отложенная операция, которую нужно применить к детям, поэтому вызовем push
    push(v);

    // получаем ответы из детей и берем минимум из них
    int tm = tl + (tr - tl) / 2;
    ll a = get(v * 2 + 1, tl, tm, l, r);
    ll b = get(v * 2 + 2, tm, tr, l, r);
    return min(a, b);
}
```