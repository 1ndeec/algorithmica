Простое разделение на блоки позволяет создать достаточно мощную
структуру, которая позволяет делать операции вставки, удаления
и подсчета некоторых функций на отрезках за корень. Рассмотрим задачу
подробнее.

## Постановка задачи

Пусть дан массив из $N$ элементов. К нему поступает $M$ запросов трех
видов:

  - Вставить элемент $x$ на позицию $i$, то есть слева от него окажется
    ровно $i$ элмементов;
  - Удалить элемент с позиции $i$;
  - Найти минимум на полуинтервале $\[l, r)$.

Будем считать, что все индексы начинаются с нуля.

## Решение с помощью корневой декомпозиции

Основная идея решения: разделим массив <em>примерно</em> на $\\sqrt{N}$
частей одинакового размера. Будем поддерживать глобальный счетчик
`OPERATIONS_COUNTER`, равный числу операций изменения, произведенных над
структурой.

### Вставка

При вставке будем явно вставлять элемент в нужный блок. Если вставка
происходит на границе блоков, то договоримся вставлять элемент в
единственный существующий блок, если вставка производится в самый
конец или в самое начало. Иначе вставляем в блок, найденный функцией
`findBlock`. Можно сделать иначе при вставке на концах - вставлять в
новый блок, создавая его. Этот случай будет лучше работать, если у
нас происходит много вставок подряд, а предыдущий способ - когда
больше надо отвечать на запросы. Можно также принимать решение о
вставке тем или иным способом случайно. Это решение, наверное, будет
наиболее универсальным и применимым.

``` c++ numberLines
void insert(int pos, int elem) {
    OPERATIONS_COUNTER++;
    if (blocks.empty()) {
        blocks.resize(1);
        blocks[0].push_back(elem);
        return;
    }
    pair<int, int> posBlock = findPosition(pos);
    if (posBlock.first == blocks.size()) {
        blocks.back().push_back(elem);
        return;
    }
    blocks[posBlocks.first].insertAtPosition(posBlock.second, elem);
```

### Удаление

При удалении будем явно удалять элемент из блока за размер блока. Если
блок оказался пустым, то ничего с ним не будем делать пока что.

### Функция на полуинтервале

Запрос о вычислении функции обрабатываем, как в обычной простой корневой
декомпозиции.

### Перестраивание

Чтобы на допускать создания слишком большого числа маленьких блоков или
разрастания отдельных блоков, раз в $\\sqrt{N}$ операций будем заново
полностью перестраивать структуру. Размер блока при этом тоже будет
меняться. Также будем всегда поддерживать размер всей структуры. Мало
ли, может пригодиться.

Предположим, что массив блоков хранится как глобальный вектор `blocks`.

``` C++ numberLines
void rebuild() {
    int newBlockSize = sqrt(size) + 1;
    vector<int> all;
    for (auto& block : blocks) {
        for (auto elem : block) {
            all.push_back(elem);
        }
    }
    blocks.clear();
    int newBlockNumber = (totalSize + newBlockSize - 1) / newBlockSize;
    blocks.resize(totalSize);
    for (int i = 0; i < totalSize; i++) {
        blocks[i / newBLockSize].push_back(all[i]);
        updateFunction(i);
    }
}
```

### Как искать нужный блок

Так как теперь мы не можем гарантировать, что блок имеет фиксированный
размер в каждый момент времени, то находить нужное место будем просто
проходом по массиву блоков. Функция возвращает номер блока и позицию
именно в нем.

``` C++ numberLines
pair<int, int> findBlock(int pos) {
    if (blocks.empty() || pos == 0) {
        return {0, 0};
    }
    int byLeft = 0;
    int i = 0;
    while (i < blocks.size() && byLeft < pos) {
        byLeft += blocks[i].size();
        i++;
    }
    i--;
    byLeft -= blocks[i].size();
    return {i, pos - byLeft};
}
```

[Категория:Конспект](Категория:Конспект "wikilink")