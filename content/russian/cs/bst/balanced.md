---
title: Применения деревьев поиска
weight: -1
---

`set` - это коллекция, которая содержит множество уникальных
упорядоченных элементов. Чтобы добавить элемент в `set`,
есть функция `insert`. В случае, если элемент уже был в множестве,
ничего не происходит. Чтобы удалить элемент из `set`, есть функция
`erase` (в нее можно передать либо итератор на элемент, либо просто
элемент). Если `erase` была вызвана с элементом, а элемента не было
в `set`, то ничего не произойдет. Чтобы посмотреть, есть ли элемент в
`set`, есть функция `count`. Она вернёт $0$, если элемента нет в
множестве, и $1$, если он есть. Также есть метод `find`, который
возвращает итератор на элемент или `end`, если элемента нет. Все
операции с элементами `set` (добавление, удаление, поиск)
работают за $O(\\log n)$, где $n$ - количество элементов в нём,
так как он реализован с помощью сбалансированного двоичного дерева
поиска.

Итераторы `set` относятся к категории `BidirectionalIterator` и имеют
тип `set`<T>`::iterator`. Начало `set` можно получить с помощью
функции `begin`, конец — с помощью функции `end`. Как и в случае с
вектором, `end` указывает на конец полуинтервала. Инкремент и декремент
итераторов `set` также работают за логарифмическое время. Стоит
отметить, что, так как элементы в set упорядочены, с помощью
`begin` и `end` можно искать наименьший/наибольший элемент в `set`.
Чтобы найти наименьший элемент, больший или равный заданному, есть
функция `lower_bound`. Чтобы найти наименьший элемент, строго больший
заданному, есть функция `upper_bound`. Каждая из этих функций
возвращает итератор на искомый элемент или `end()`, если такого
элемента не существует. `set` может содержать только элементы тех типов,
для которых определён оператор `<`, поскольку ему важен порядок
элементов. Рассмотрим пример простейших операций с `set`.

``` C++
set<int> s;

s.insert(3); // s = {3}
s.insert(2); // s = {2, 3}
cout << s.size() << "\n"; // выведет 2

s.insert(3); // 3 не будет добавлено ещё раз, так как уже присутствует в множестве
cout << s.size() << "\n"; // выведет 2

s.insert(5); // s = {2, 3, 5}
cout << s.count(3) << "\n"; // выведет 1
cout << s.count(4) << "\n"; // выведет 0

s.erase(3); // s = {2, 5}
s.insert(6); // s = {2, 5, 6}

set<int>::iterator it1 = s.find(5);
it1++;
cout << *it1 << "\n"; // выведет 6

auto it2 = s.lower_bound(1);
cout << *it2 << "\n"; // выведет 2, так как это первый элемент >= 1

auto it3 = s.upper_bound(2);
cout << *it3 << "\n"; // выведет 5, так как это первый элемент > 2.

auto it4 = s.upper_bound(10);
if (it4 == s.end()) {
    cout << "No element > 10\n"; // аккуратно, если разыменуете it4, получите undefined behaviour!
}

// вывод всех элементов сета с использованием итераторов; элементы следуют в порядке возрастания
for (auto it = s.begin(); it != s.end(); it++) {
    cout << *it << " ";
}
cout << "\n"; // но для таких целей лучше использовать range-based for loop!
```

`map` — это ассоциативный контейнер: он содержит пары ключ-значение, при
этом все ключи уникальны. Внутри контейнера все ключи упорядочены по
возрастанию. Так же, как и в `set`, операции работают за
логарифмическое время.

Объявление `map` выглядит так: `map<T1, T2> map_name`, где `T1` — тип
ключа, `T2` — тип значения.

Доступ к элементам `map` осуществляется с помощью оператора `[]`. `map`,
аналогично `set`, поддерживает поиск по ключу с помощью `find`,
`lower_bound`, `upper_bound`. При разыменовании итератора получается
пара, первый элемент которой — ключ, второй — значение.

При обращении к несуществующему элементу `map` с помощью `[]`, значение
инициализируется значением по умолчанию для данного типа. Рассмотрим
работу `map` на примере:

``` C++
map<int, int> a;
a[13] = 5;
a[2] = 7;
cout << a[2] << "\n"; // выведет 7
a[2]++;
cout << a[2] << "\n"; // выведет 8
a[100] = 42;

/* Следующий цикл выведет 3 строки:
   2 8
   13 5
   100 42

   Обратите внимание, что ключи упорядочены.
*/
for (auto el : a) {
    cout << el.first << " " << el.second << "\n";
}


map<string, int> b;
b["Bob"]--;
b["Alice"] += 2;
b["Dan"] = 123;

/* Этот цикл выведет 2 строки:
   Alice 2
   Bob -1
   Dan 123
*/
for (auto el : b) {
    cout << el.first << " " << el.second << "\n";
}

map<string, vector<int>> c;
c["wow"].push_back(2);
c["abc"] = {2, -1, 17};
cout << c["abc"].size() << "\n"; // выведет 3
```

`multiset` - то же, что и `set`, но может содержать повторяющиеся
элементы. `count` работает за $O(\\log{n} + c)$, где $c$ -
количество искомых элементов. Поэтому, чтобы проверить наличие
элемента $x$ в `multiset s`, надо воспользоваться: `s.find(el) !=
s.end()`. `erase` удаляет все элементы с таким значением. Чтобы удалить
один, надо написать: `s.erase(s.find(x))`. Но нужно быть аккуратнее с
таким способом, т.к. здесь происходит удаление по итератору. То есть,
если элемента в множестве не будет, `s.find(x)` вернет `s.end()`, и
программа при удалении, скорее всего, упадет.
