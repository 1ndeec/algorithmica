---
title: Алгоритм Грэхема
---

Алгоритм Грэхема — это оптимизация алгоритма Джарвиса, основанная на следующем наблюдении: если отсортировать все точки по полярному углу относительно точки $p_0$, то выпуклая оболочка будет какой-то подпоследовательностью такого отсортированного массива точек.

Алгоритм последовательно строит выпуклые оболочки для каждого префикса этого отсортированного масива. При добавлении $i$-й точки в оболочку нужно удалить сколько-то последних добавленных точек, которые не будут входить в новую оболочку. Чтобы это делать эффективно, мы можем хранить выпуклую оболочку в стеке и в цикле `while` смотреть на три последние точки и проверять, образуют ли они правый поворот. Если это так, то среднюю следует удалить — мы нашли треугольник $(p_0, p_i, p_{i-2})$, который содержит $p_{i-1}$, значит её можно удалить.

![alt text](https://cdn.turkaramamotoru.com/ru/algoritm-grehema-4131.jpg)

Каждая точка будет добавлена один раз удалена не более одного раза, что занимает константное количество операций. Соответственно, время работы будет упираться во время работы сортировки, то есть $O(n \log n)$.

```c++
struct r {
    int x, y;
    r operator-(r a) {return {x - a.x; y - a.y};}
    // в векторном произведении возможно переполнение int
    int operator^(r a) {return x * a.y - y * a.x;}
};
vector<r> graham_convex_hull(vector<r> points) {
    // находим p0, как и раньше
    r p0 = points[0];
    for (r p : points)
        if (p.x < p0.x || (p.x == p0.x && p.y < p0.y))
            p0 = p;

    // TODO: удалить p0
    // сделаем p0 началом координат (для сокращения кода компаратора)
    for (r &x : points) {
        x.x -= p0.x;
        x.y -= p0.y;
    }
    // сортируем точки по полярному углу
    sort(points.begin(), points.end(), [&](r a, r b){
        return a ^ b > 0 || a ^ b == 0 && a.x * a.x + a.y * a.y < b.x * b.x + b.y * b.y;
    }); // если векторное произведение == 0 то сначала будем рассматривать точку, которая ближе к p0

    vector<r> hull;
    for (r p : points) {
        // удаляем последнюю точку МВО пока она образует невыпуклость (оператор "-" у точек должен быть перегружен, как и "^"
        /*
        Пусть т. A - последняя в оболочке, т. B - предпоследняя, т. C - точка, которую мы хотим добавить
        Тогда невыпуклость(или вырожденность) образуется, когда (C - A) ^ (B - A) <= 0
        */
        while (hull.size() >= 2 && ((p - hull.back()) ^ (hull[hull.size() - 2] - hull.back()) <= 0) {
             hull.pop_back();
        }
        hull.push_back(p);
    }
    // переместим начало координат обратно
    for (r &x : hull) {
        x.x += p0.x;
        x.y += p0.y;
    }
    return hull;
}
```

https://visualgo.net/en/convexhull
