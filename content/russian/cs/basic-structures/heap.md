---
title: Двоичная куча
weight: 1
---

*Куча* (англ. *heap*) — абстрактная структура данных, поддерживающая следующие операции:

1. Нахождение минимума.
2. Удаление минимума.
3. Добавление нового элемента в кучу.

Другое название, лучше отражающее функциональность — *очередь с приоритетами* (англ. *priority queue*).

Кучи используются во многих алгоритмах. Например, кучи используются в алгоритмах поиска [кратчайшего пути](/cs/graphs/shortest-paths/dijkstra), а также помощью кучи можно проводить [сортировку](/cs/sorting/heapsort) (путём превращения массива в кучу, а кучу в отсортированный массив).

В STL куча реализована адаптером `priority_queue`, в котором нахождение максимального (по умолчанию) элемента работает за $O(1)$, а добавление и удаление — за $O(\log n)$:

```cpp
priority_queue<int> q;

for (int x : {1,5,3,4,2,0})
    q.push(x);

q.top(); // вернуть максимальный элемент
q.pop(); // удалить максимальный элемент
```

Также часто в качестве куч часто используют любые [бинарные деревья поиска](../bst), в частности `std::set`.


*Двоичная куча* (пирамида, сортирующее дерево, англ. *binary heap*) — реализация [очереди с приоритетами](../), использующая дерево, для которого выполнены три условия:

1. Значение в любой вершине не меньше, чем значения её потомков.
2. У любой вершины не более двух сыновей (дерево бинарное).
3. Слои заполняются последовательно сверху вниз и слева направо, без «дырок».

![Двоичная куча для максимума](/img/binary-heap.svg)

Обозначим высоту дерева как $h$. Так как куча всегда состоит из нескольких слоев заполненных полностью и одного заполненного частично, и каждый следующий слой содержит в два раза больше вершин, чем предыдущий, то высота дерева будет $\Theta(\log(N))$.

Двоичная куча умеет выполнять 3 основные операции:

1. Нахождение минимума $O(1)$.
2. Удаление минимума за $O(h)$.
3. Добавление нового элемента в кучу за $O(h)$.

## Реализация

Хранить кучу будем в виде массива $t$, где у корня индекс равен $1$, а у вершины $k$ индексы ее потомков — $2k$ и $(2k + 1)$. Нулевая ячейка массива при этом остается пустой.

![Представление кучи в памяти](/img/heap-layout.svg)

Дальше определим две вспомогательные функции, которые восстанавливают инварианты кучи при изменении значения одного элемента.

Если значение элемента *уменьшается*, то чтобы исполнялось первое условие кучи, его возможно нужно переместить выше. Это можно сделать, несколько раз итеративно меняя элемент с его непосредственным родителем, если его значение больше. Так как каждый раз мы поднимаемся по дереву, то работать такая функция будет за его высоту:

```cpp
void sift_up(int v) {
    // если элемент больше своего отца, то всё корректно и больше ничего делать не нужно
    while (v > 1 && t[v] < t[v / 2]) {
        // иначе меняем его с отцом и запускаемся от отца
        swap(t[v], t[v / 2]);
        v /= 2;
    }
}
```

Если значение измененного элемента *увеличивается*, то нам нужно наоборот переместить его ниже. Это можно сделать похожим способом, итеративно меняя его с меньшим из сыновей и продолжая уже от него. Аналогично, каждый раз мы спускаемся глубже, поэтому эта процедура будет работать тоже за высоту дерева:

```cpp
void sift_down(int v) {
    // пока не пришли в лист
    while (2 * v <= n) { // n -- количество элементов в куче
        int l = 2 * v; // левый сын
        int r = 2 * v + 1; // правый сын
        // если правый сын существует и меньше, выбираем его
        int u = (r <= n && t[r] < t[l] ? r : l);
        if (t[v] <= t[u])
            break; // инвариант и так выполняется, завершаемся
        swap(t[v], t[u]);
        v = u;
   }
}
```

Для понимания рекомендуем посмотреть [визуализацию](https://visualgo.net/en/heap).

Вернемся теперь к «полезным» операциям.

1. Минимум мы можем выполнить за константу, просто вернув корень, то есть первый элемент массива.
2. Для удаления минимума мы можем заменить значение корня на значение последнего элемента массива, уменьшить размер кучи, а затем запустить `sift_down` от корня.
3. Для добавления элемента добавим его в конец массива, а затем вызовем `sift_up` от него.

## В стандартной библиотеке

В STL доступны несколько примитивов для работы с бинарными кучами поверх массивов:

```cpp
int ints[] = {10,20,30,5,15};
vector<int> v(ints, ints + 5);

make_heap(v.begin(), v.end());
v.front(); // получить максимальный элемент (30)

pop_heap(v.begin(), v.end()); // удалить максимум из кучи
v.pop_back(); // уменьшить размер массива на единицу

v.push_back(99); // добавить элемент в конец массива
push_heap(v.begin(), v.end()); // вызовет sift_up от последнего элемента

sort_heap(v.begin(), v.end()); // сортировка кучей: в v будет записан отсортированный массив
```

Однако напрямую они используются довольно редко.
