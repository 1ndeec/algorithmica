---
title: «Лямбда-оптимизация»
---

**Примечание.** В научной литературе метод известен как дискретный метод множителей Лагранжа.

Рассмотрим немного другую задачу. Пусть нам нужно покрыть те же точки, но теперь нас не ограничивают жёстко в количестве отрезков, а просто штрафуют на какую-то константу $\lambda$ за использование каждого. Нашу оптимизируемую функцию $g$ можно выразить через $f$ следующим образом:

$$
g[i] = \min_{k < i} \{f[i, k] + k \cdot \lambda \}
$$

 Однако её можно считать по более оптимальной формуле, не сводя к вычислению $f$:

$$
g[i] = \lambda + \min_{k < i} \{g[k] + (x_{i-1} - x_k)^2 \}
$$

Эту динамику можно посчитать за $O(n)$ — мы это делали полстраницы назад с помощью Convex Hull Trick.

**Наблюдение 1.** Если в оптимальном решении для $g_i$ мы для какого-то $\lambda$ использовали ровно $k$ отрезков, то это же решение будет оптимальным и для $f[i][k]$.

**Наблюдение 2.** Если уменьшать $\lambda$, то оптимальное количество отрезков для для $g_i$ будет увеличиваться.

Основная идея оптимизации: сделаем бинпоиск по $\lambda$, внутри которого будем находить оптимальное решение для $g_i$ с таким $\lambda$. Если оптимальное $k$ больше $j$, то следующая $\lambda$ должна быть меньше, а в противном случае наоборот. Когда $k$ совпадёт с $j$, просто выведем «чистую» стоимость получившегося решения.

Таким образом, задача решается за $O(n \log n + n \log m)$, если сортировку точек для CHT делать заранее, а не внутри бинпоиска.

Мы не учли только одну деталь: почему вообще существует такая $\lambda$, что оптимальное $k = j$. Возможно, что функция $k(\lambda)$ через него «перескакивает». В общем случае это действительно проблема: одной лишь монотонности не достаточно, чтобы решать подобным образом произвольные задачи с ограничением на число объектов.

**Утверждение.** Функция $f[i, j]$ *нестрого вогнутая* (то есть выпуклая вверх) по своему второму аргументу, то есть:

$$
f[i, j] - f[i, j-1] \leq f[i, j+1] - f[i, j]
$$

Иными словами, «выгода» добавления следующего отрезка с каждым разом не увеличивается. Тогда если мы найдем минимальную $\lambda$ такую, что $k \ge j$, то $f[i, k] = f[i, j]$.

```c++
pair<ll, int> dp[maxn]; // dp[i] - (ответ, число отрезков)

void init() {
    for (int i = 0; i < maxn; i++) {
        dp[i] = make_pair(inf, 0);
    }
}

pair<ll, int> check(ll x) { // это можно соптимизировать
    init();
    dp[0] = make_pair(0ll, 0); // 1-индексация
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] = min(dp[i], {dp[j].first + cost[j + 1][i] + x, dp[j].second + 1});
        }
    }
    return dp[n];
}

ll solve() {
    ll l = -1e14; // границы надо подбирать очень аккуратно!
    ll r = 1;
    while (l + 1 < r) {
        ll mid = (l + r) / 2;
        pair<ll, int> x = check(mid);
        if (x.second >= k) {
            l = mid;
        }
        else {
            r = mid;
        }
    }
    pair<ll, int> result = check(l);
    return result.first - l * return.second; // вычитаем штрафы
}
}
```
