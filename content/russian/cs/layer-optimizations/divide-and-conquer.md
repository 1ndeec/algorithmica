---
title: Оптимизация через разделяй-и-властвуй
weight: 1
---

Обозначим за $opt[i, j]$ оптимальный $k$, то есть тот, на котором $f[i, j] = f[k, j-1] + (x_{i-1}-x_k)^2$ минимизируется. Для однозначности, если оптимальный индекс не один, то выберем среди них самый правый.

**Утверждение.** $opt[i, j] \leq opt[i, j+1]$.

Интуиция такая: если у нас появился дополнительный отрезок, то последний отрезок нам не выгодно делать больше.

Что это нам даёт? Если мы уже знаем $opt[i, l]$ и $opt[i, r]$ и хотим посчитать $opt[i, j]$ для какого-то $j$ между $l$ и $r$, то мы можем сузить отрезок поиска оптимального индекса со всего $[0, i-1]$ до $[opt[i, l], opt[i, r]]$.

Будем делать следующее: заведем рекурсивную функцию, которая считает динамики для отрезка $[l, r]$, зная, что их $opt$-ы лежат между $l'$ и $r'$. Она берет середину отрезка $[l, r]$ и линейным проходом считает ответ для неё, а затем просто спускается дальше рекурсивно.

```c++
void solve(int l, int r, int _l, int _r, int k) {
    if (l > r)
        return; // отрезок пустой -- выходим
    int t = (l + r) / 2, opt = _l;
    for (int i = _l; i <= min(_r, t); i++) { 
        int val = f[i+1][k-1] + cost(i, j);
        if (val < f[t][k])
            f[t][k] = val, opt = i;
    }
    solve(l, t-1, _l, opt, k);
    solve(t+1, r, opt, _r, k);
}
```

Затем последовательно вызовем её для каждого слоя:

```c++
for (int k = 1; k <= m; k++)
    solve(0, n-1, 0, n-1, k);
```

**Асимптотика.** Теперь пересчет одного «слоя» динамики занимает $O(n \log n)$ вместо $O(n^2)$, потому что каждый раз рекурсивная функция уменьшает в два раза хотя бы один из отрезков. Так как максимальная глубина рекурсии будет $O(\log n)$, то каждый элемент будет просмотрен не более $O(\log n)$ раз.

Таким образом, мы улучшили асимптотику до $O(n m \log n)$.

---

Пусть у нас была динамика $dp_i = \\min_{k=1}^i f(i, k)$, для которой
выполнялась [монотонность точки
перегиба](монотонность_точки_перегиба "wikilink")
($opt_{i} \\le opt_j$) (а еще $f(i, k)$ не зависела от $dp$).
Divide\&Conquer оптимизация позволяет посчитать эту динамику за $O(n
\\log n)$.

#### Идея

Давайте мы будем считать значения динамики не по порядку, а по принципу
"разделяй и властвуй". Сначала посчитаем динамику для средней точки,
потом рекурсивно сделаем аналогичное действие для левой и правой
частей массива. Пока что это все еще работает за квадратичное время,
но посмотрим на происходящий процесс внимательнее. Когда мы считали
динамику для отрезка $\[l, r\]$, мы посчитали $opt_{\\frac{l +
r}{2}}$. Из [монотонности точки
перегиба](монотонность_точки_перегиба "wikilink")
$opt$ для всех элементов на $\[l, \\frac{l + r}{2}\]$ будет не больше
$opt_{\\frac{l + r}{2}}$, а для $\[\\frac{l + r}{2}, r\]$ — не меньше.
Поэтому будем поддерживать в рекурсии "активный" отрезок с теми
индексами, которые могут быть точками оптимума для динамики. На
каждом уровне рекурсии суммарная длина отрезков будет $O(n)$, поэтому
суммарно алгоритм потребует $O(n \\log n)$ времени.

#### Реализация

В слоистой динамике реализация будет выглядеть так:

``` c++ numberLines
int layer;
void calc(int tl, int tr, int l, int r) {
    if (tl > tr) {
        return;
    }
    int tm = (tl + tr) / 2;
    int opt = -1;
    for (int i = l; i <= min(r, tm - 1); i++) {
        if (dp[tm][layer] > dp[i][layer - 1] + cost(i + 1, tm)) {
            dp[tm][layer] = dp[i][layer - 1] + cost(i + 1, tm);
            opt = i;
        }
    }
    calc(tl, tm - 1, l, opt);
    calc(tm + 1, tr, opt, r);
}
```
