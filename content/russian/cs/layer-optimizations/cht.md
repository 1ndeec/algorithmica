Рассмотрим следующую задачу:

<i>Вася надувает воздушный шар. Каждую секунду он может либо
дополнительно надуть шар, либо ничего не делать. Если он
надувает шар в $i$-ю секунду, то радиус увеличивается на $a_i$, но
после этого радиус будет уменьшаться на $b_i$ в секунду до следующего
поддува. Найдите максимальный радиус шара, который можно получить за
$n$ секунд.</i>

Данную задачу можно решить с помощью динамического программирования.
$dp_i$ — это наилучший радиус, который можно получить через $i$ секунд.
Тогдв $$dp_i = \\max_{j=1}^{i-1} dp_j + a_j - b_j \\cdot (i - j) =
\\max_{j=1}^{i-1} (-b_j) \\cdot i + (dp_j + a_j + b_j \\cdot j) =
\\max_{j=1}^{i-1} A_j \\cdot i + B_j$$ где $A, B$ зависят только от
$j$. То есть можно считать, что нам надо найти минимальное значение
среди линейных функций в точке $i$.

#### Convex hull

Будем поддерживать структуру данных, которая позволяет:

  - добавить линейную функцию
  - найти максимальное значение в данном множестве функций в точке $x$

Заметим, что данная функция будет иметь вид верхней огибающей.
Пересечение новой линейной функции и огибающей не может имметь
больше двух точек. Тогда нам надо научиться удалить из огибающей все
прямые, которые из нее целиком пропали, а после добавить новую
прямую и точки пересечения.

Такие операции действительно можно делать, если сложить все прямые в
`std::set`, находить [бинпоиском](бинарный_поиск "wikilink") те прямые,
с которыми надо пересечь новую, и удалять все прямые между ними. Это
будет работать за $O(n \\log n)$, но пишется достаточно тяжело, и
нужно редко. Кроме того, такую задачу можно решать, используя
[дерево Li Chao](дерево_Li_Chao "wikilink")

Гораздо чаще в задаче бывает ограничение на монотонное изменение
линейного коэффициента прямых (в нашем случае, $-b_i$). Тогда
прямые нужно добавлять не в произвольное место структуры данных, а
только в конец. В таком случае можно заменить `std::set` на
[стек](стек "wikilink"). Тогда находить точки пересечения можно не
бинпоиском, а постепенным удалением "бесполезных" прямых. Таким образом,
структуру можно реалиизовать с суммарным временем работы $O(n)$, если
запросы по $x$ тоже были отсортированы (если не были, то отвечать на
запрос бы будем за $O(\\log n)$.

#### Реализация

В раиках данной реализации мы храним две величины: массив прямых $lines$
и массив точек изменений $pr$. Считаем, что $lines_i$ является
минимальной на промежутке $\[pr_i, pr_{i + 1}\]$.

``` c++ numberLines
struct Line {
    int k, m;
};

vector<int> pr; // если округлять точку пересечения вниз, то можно хранить их в целых числах
vector<Line> lines;

int get(int x) {
    int l = 0;
    int r = lines.size();
    while (l + 1 < r) {
        int mid = (l + r) / 2;
        if (pr[mid] <= x) {
            l = mid;
        }
        else {
            r = mid;
        }
    }
    return lines[l].k * x + lines[l].m;
}

void upd(Line line) {
    while (lines.size() && line.k * pr.back() + line.m < lines.back().k * pr.back() + lines.back().m) {
        pr.pop_back();
        lines.pop_back();
    }
    int coord;
    if (lines.empty()) {
        coord = -INF;
    } else {
        coord = cross(line, lines.back()); // нужно реализовать пересечение прямых
    }
    pr.push_back(coord);
    lines.push_back(line);
}
```

[Категория:Конспект](Категория:Конспект "wikilink")
[Категория:Оптимизации
динамики](Категория:Оптимизации_динамики "wikilink")