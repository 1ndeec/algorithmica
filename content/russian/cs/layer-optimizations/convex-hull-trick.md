---
title: Convex Hull Trick
weight: 3
---

Возьмём исходную формулу для $f$ и раскроем скобки в `cost`:

$$
f[i, j] = \min_{k < i} \{ f[k, j-1] + (x_{i-1}-x_k)^2 \} = \min_{k < i} \{
f[k, j-1] + x_{i-1}^2
- 2x_{i-1} x_k
+ x_k^2
\}
$$

Заметим, что $x_{i-1}^2$ не зависит от $k$, значит его можно вынести. Под минимумом тогда останется

$$
\underbrace{f[k, j-1] + x_k^2}_{a_k}
\underbrace{-2x_k}_{b_k} x_{i-1}
$$

Это выражение можно переписать как $\min_k (a_k, b_k) \cdot (1, x_{i-1})$, где под «$\cdot$» имеется в виду скалярное произведение.

![](img/scooby-doo.jpg)

Пусть мы хотим найти оптимальное $k$ для $f[i][j]$. Представим все уже посчитанные релевантные динамики с предыдущего слоя как точки $(a_k, b_k)$ на плоскости. Чтобы эффективно находить среди них точку с минимальным скалярным произведением, можно поддерживать их *нижнюю огибающую* (вектор $(1, x_{i-1})$ «смотрит» всегда вверх, поэтому нам интересна только она) и просто бинпоиском будем находить оптимальную точку.

Хранить нижнюю огибающую можно просто в стеке. Так как добавляемые точки отсортированы по $x$, её построение будет занимать линейное время, а асимптотика всего алгоритму будет упираться в асимптотику бинарного поиска, то есть будет равна $O(n m \log n)$

```c++
struct line {
    int k, b;
    line() {}
    line(int a, int _b) { k = a, b = _b; }
    int get(int x) { return k * x + b; }
};

vector<line> lines; // храним прямые нижней огибающей
vector<int> dots; // храним x-координаты точек нижней огибающей
//     ^ первое правило вещественных чисел
//      считаем, что в dots лежит округленная вниз x-координата

int cross(line a, line b) { // считаем точку пересечения
                            // считаем a.k > b.k
    int x = (b.b - a.b) / (a.k - b.k);
    if (b.b < a.b) x--; // боремся с округлением у отрицательных чисел
    return x;
}


void add(line cur) {
    while (lines.size() && lines.back().get(dots.back()) > cur.get(dots.back())) {
        lines.pop_back();
        dots.pop_back();
    }
    if (lines.empty())
        dots.push_back(-inf);
    else 
        dots.push_back(cross(lines.back(), cur));
    lines.push_back(cur);
}

int get(int x) {
    int pos = lower_bound(dots.begin(), dots.end(), x) - dots.begin() - 1;
    return lines[pos].get(x);
}

```

В случае нашей конкретной задачи, алгоритм можно и дальше соптимизировать, если вспомнить, что $opt[i, j] \leq opt[i][j+1]$, то есть что оптимальная точка всегда будет «правее». Это позволяет вместо бинпоиска применить метод двух указателей:

```c++
// TODO: закомитьте кто-нибудь реализацию на гитхаб
```

Мы избавились от бинпоиска, и теперь алгоритм работает за $O(n \cdot m)$.

### Дерево Ли Шао

Существует другой подход к Convex Hull Trick: увидеть здесь не точки и оптимизацию скалярного произведения, а линии и нахождение минимума в точке среди этих линий.

![](https://i.imgur.com/TqfVWDD.png)

Применительно к нашей задаче, выражение $\min_k (a_k, b_k) \cdot (1, x_{i-1})$ можно раскрыть как $\min_k (a_k + b_k \cdot x_{i-1})$ и представить как нахождение минимума в точке среди множества прямых вида $y = a_k + b_k \cdot x$.

*Дерево Ли Шао* (англ. *Li Chao segment tree*, кит. *李超段树*) — модификация дерева отрезков над множеством возможных $x$, каждая вершина которого хранит в себе такую прямую, что если пройти по пути от корня до соответствующего листа, то максимум в данной точке будет наибольшее значение на пути.

![](https://raw.githubusercontent.com/e-maxx-eng/e-maxx-eng/mastimg/li_chao_vertex.png)

Пусть в вершину пришло обновление — прямая *new*. Если в ней ничего не хранится, то запишем *new* в вершину и выйдем. Если там уже есть какая-то другая прямая *old*, то одна из них будет «доминировать» над другой хотя бы на одной из половин, а в другой будет либо пересекаться, либо тоже доминировать.

Если одна прямая полностью доминирует над другой, то мы её просто запишем в вершину, а про вторую забудем. Если же прямая доминирует только в одной из половин, то мы запишем её, а «проигравшую» прямую передадим в рекурсию в ту половину, где она может доминировать.

```c++
typedef int ftype;
typedef complex<ftype> point;
#define x real
#define y imag

ftype dot(point a, point b) {
    return (conj(a) * b).x();
}

ftype f(point f, ftype x) {
    return dot(f, {x, 1});
}

const int inf = 1e6 + 42;

point ln[8 * inf];
void add_line(point nw, int v = 1, int l = -inf, int r = inf) {
    point ol = ln[v];
    int m = (l + r) / 2;
    bool lef = f(nw, l) > f(ol, l);
    bool mid = f(nw, m) > f(ol, m);
    ln[v] = mid ? nw : ol;
    if(r - l == 1)
        return;
    if(lef != mid)
        add_line(mid ? ol : nw, 2 * v, l, m);
    else
        add_line(mid ? ol : nw, 2 * v + 1, m, r);
}

int get(int x, int v = 1, int l = -inf, int r = inf) {
    if(r - l == 1)
        return f(ln[v], x);
    int m = (l + r) / 2;
    if(x < m)
        return max(f(ln[v], x), get(x, 2 * v, l, m));
    else
        return max(f(ln[v], x), get(x, 2 * v + 1, m, r));
}
```

Достаточно полезно сравнить между собой CHT и дерево Ли-Шао и понимать, в какой из ситуаций стоит применять каждую из этих структур. Адекватные реализации CHT требуют особых условий — точки должны быть отсортированы по $x$. Если это выполнено, то работать алгоритм будет значительно быстрее, чем дерево Ли Шао, которое, в свою очередь, решает более общую задачу, но работает за $O(\log MAXC)$ на запрос, а зачастую еще и требует неявную реализацию, если $MAXC$ достаточно большое (неявная реализация схожа с [неявным деревом отрезков](segtree)).

---

Рассмотрим следующую задачу:

<i>Вася надувает воздушный шар. Каждую секунду он может либо
дополнительно надуть шар, либо ничего не делать. Если он
надувает шар в $i$-ю секунду, то радиус увеличивается на $a_i$, но
после этого радиус будет уменьшаться на $b_i$ в секунду до следующего
поддува. Найдите максимальный радиус шара, который можно получить за
$n$ секунд.</i>

Данную задачу можно решить с помощью динамического программирования.
$dp_i$ — это наилучший радиус, который можно получить через $i$ секунд.
Тогдв $$dp_i = \\max_{j=1}^{i-1} dp_j + a_j - b_j \\cdot (i - j) =
\\max_{j=1}^{i-1} (-b_j) \\cdot i + (dp_j + a_j + b_j \\cdot j) =
\\max_{j=1}^{i-1} A_j \\cdot i + B_j$$ где $A, B$ зависят только от
$j$. То есть можно считать, что нам надо найти минимальное значение
среди линейных функций в точке $i$.

#### Convex hull

Будем поддерживать структуру данных, которая позволяет:

  - добавить линейную функцию
  - найти максимальное значение в данном множестве функций в точке $x$

Заметим, что данная функция будет иметь вид верхней огибающей.
Пересечение новой линейной функции и огибающей не может имметь
больше двух точек. Тогда нам надо научиться удалить из огибающей все
прямые, которые из нее целиком пропали, а после добавить новую
прямую и точки пересечения.

Такие операции действительно можно делать, если сложить все прямые в
`std::set`, находить [бинпоиском](бинарный_поиск "wikilink") те прямые,
с которыми надо пересечь новую, и удалять все прямые между ними. Это
будет работать за $O(n \\log n)$, но пишется достаточно тяжело, и
нужно редко. Кроме того, такую задачу можно решать, используя
[дерево Li Chao](дерево_Li_Chao "wikilink")

Гораздо чаще в задаче бывает ограничение на монотонное изменение
линейного коэффициента прямых (в нашем случае, $-b_i$). Тогда
прямые нужно добавлять не в произвольное место структуры данных, а
только в конец. В таком случае можно заменить `std::set` на
[стек](стек "wikilink"). Тогда находить точки пересечения можно не
бинпоиском, а постепенным удалением "бесполезных" прямых. Таким образом,
структуру можно реалиизовать с суммарным временем работы $O(n)$, если
запросы по $x$ тоже были отсортированы (если не были, то отвечать на
запрос бы будем за $O(\\log n)$.

#### Реализация

В раиках данной реализации мы храним две величины: массив прямых $lines$
и массив точек изменений $pr$. Считаем, что $lines_i$ является
минимальной на промежутке $\[pr_i, pr_{i + 1}\]$.

``` c++ numberLines
struct Line {
    int k, m;
};

vector<int> pr; // если округлять точку пересечения вниз, то можно хранить их в целых числах
vector<Line> lines;

int get(int x) {
    int l = 0;
    int r = lines.size();
    while (l + 1 < r) {
        int mid = (l + r) / 2;
        if (pr[mid] <= x) {
            l = mid;
        }
        else {
            r = mid;
        }
    }
    return lines[l].k * x + lines[l].m;
}

void upd(Line line) {
    while (lines.size() && line.k * pr.back() + line.m < lines.back().k * pr.back() + lines.back().m) {
        pr.pop_back();
        lines.pop_back();
    }
    int coord;
    if (lines.empty()) {
        coord = -INF;
    } else {
        coord = cross(line, lines.back()); // нужно реализовать пересечение прямых
    }
    pr.push_back(coord);
    lines.push_back(line);
}
```

[Категория:Конспект](Категория:Конспект "wikilink")
[Категория:Оптимизации
динамики](Категория:Оптимизации_динамики "wikilink")
