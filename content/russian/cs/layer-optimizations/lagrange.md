---
title: Дискретный метод Лагранжа
weight: 4
---

**Примечание.** В научной литературе метод известен как дискретный метод множителей Лагранжа.

Рассмотрим немного другую задачу. Пусть нам нужно покрыть те же точки, но теперь нас не ограничивают жёстко в количестве отрезков, а просто штрафуют на какую-то константу $\lambda$ за использование каждого. Нашу оптимизируемую функцию $g$ можно выразить через $f$ следующим образом:

$$
g[i] = \min_{k < i} \{f[i, k] + k \cdot \lambda \}
$$

 Однако её можно считать по более оптимальной формуле, не сводя к вычислению $f$:

$$
g[i] = \lambda + \min_{k < i} \{g[k] + (x_{i-1} - x_k)^2 \}
$$

Эту динамику можно посчитать за $O(n)$ — мы это делали полстраницы назад с помощью Convex Hull Trick.

**Наблюдение 1.** Если в оптимальном решении для $g_i$ мы для какого-то $\lambda$ использовали ровно $k$ отрезков, то это же решение будет оптимальным и для $f[i][k]$.

**Наблюдение 2.** Если уменьшать $\lambda$, то оптимальное количество отрезков для для $g_i$ будет увеличиваться.

Основная идея оптимизации: сделаем бинпоиск по $\lambda$, внутри которого будем находить оптимальное решение для $g_i$ с таким $\lambda$. Если оптимальное $k$ больше $j$, то следующая $\lambda$ должна быть меньше, а в противном случае наоборот. Когда $k$ совпадёт с $j$, просто выведем «чистую» стоимость получившегося решения.

Таким образом, задача решается за $O(n \log n + n \log m)$, если сортировку точек для CHT делать заранее, а не внутри бинпоиска.

Мы не учли только одну деталь: почему вообще существует такая $\lambda$, что оптимальное $k = j$. Возможно, что функция $k(\lambda)$ через него «перескакивает». В общем случае это действительно проблема: одной лишь монотонности не достаточно, чтобы решать подобным образом произвольные задачи с ограничением на число объектов.

**Утверждение.** Функция $f[i, j]$ *нестрого вогнутая* (то есть выпуклая вверх) по своему второму аргументу, то есть:

$$
f[i, j] - f[i, j-1] \leq f[i, j+1] - f[i, j]
$$

Иными словами, «выгода» добавления следующего отрезка с каждым разом не увеличивается. Тогда если мы найдем минимальную $\lambda$ такую, что $k \ge j$, то $f[i, k] = f[i, j]$.

```c++
pair<ll, int> dp[maxn]; // dp[i] - (ответ, число отрезков)

void init() {
    for (int i = 0; i < maxn; i++) {
        dp[i] = make_pair(inf, 0);
    }
}

pair<ll, int> check(ll x) { // это можно соптимизировать
    init();
    dp[0] = make_pair(0ll, 0); // 1-индексация
    for (int i = 1; i <= n; i++) {
        for (int j = 0; j < i; j++) {
            dp[i] = min(dp[i], {dp[j].first + cost[j + 1][i] + x, dp[j].second + 1});
        }
    }
    return dp[n];
}

ll solve() {
    ll l = -1e14; // границы надо подбирать очень аккуратно!
    ll r = 1;
    while (l + 1 < r) {
        ll mid = (l + r) / 2;
        pair<ll, int> x = check(mid);
        if (x.second >= k) {
            l = mid;
        }
        else {
            r = mid;
        }
    }
    pair<ll, int> result = check(l);
    return result.first - l * return.second; // вычитаем штрафы
}
}
```

---

Рассмотрим следующую задачу: Дан массив $a_1, a_2, \\dots, a_n$. Надо
разбить его на $k$ отрезков так, чтобы минимизировать сумму квадратов
сумм отрезков, $k \\le n$.

Сведем задачу к другой — вместо того, чтобы набирать $k$ отрезков,
придумаем разбиение на сколько-нибудь отрезков, но за каждый
отрезок будем добавлять к функции ответа штраф, равный $\\lambda$.
Пусть для $\\lambda_1$ количество отрезков в разбиении равно $k_1$.
Тогда для $\\lambda_2 \< \\lambda_1$ $k_2 \\ge k_1$. Интуиция у
этого факта такая — если мы за каждый отрезок платим меньше, то мы
можем взять больше отрезков. Понятно, что если данное неравенство не
выполняется, то лямбда-оптимизация не работает.

Поскольку зависимость между $k$ и $\\lambda$ монотонная, то можно
сделать [бинарный поиск](бинарный_поиск "wikilink") по $\\lambda$
и найти такую, при которой $k_\\lambda=k$. Новую задачу можно решать
при помощи [convex hull trick](convex_hull_trick "wikilink"), потому
что $$dp_i = \\min_{j=1}^{i-1} dp\[j\] + \\lambda + pref_i^2 - (2
\\cdot pref_j) \\cdot pref_i + pref_j^2$$ где $pref$ — массив
префиксных сумм.

``` c++ numberLines

pair<int, int> calc(int X) {
    vector<pair<int, int>> dp(n + 1);
        add(0, 0);
    for (int i = 1; i <= n; i++) {
        int argmin = get(pref[i]);
        dp[i].first = dp[argmin].first + X + pref[i] * pref[i] - 2 * pref[argmin] * pref[i] + pref[argmin] * pref[argmin];
        dp[i].second = dp[argmin].second + 1;
        add(-2 * pref[i], dp[i] + pref[i] * pref[i])
    }
    return dp[n];
}
/*
.
.
.
*/

int L = -INF;
int R = INF;
while (L + 1 < R) {
    int mid = (L + R) / 2;
    pair<int, int> X = calc(mid);
    if (X.second > k) {
        R = mid;
    }
    else {
        L = mid;
    }
}
pair<int, int> res = check(R);
cout << res.first - k * R;
```
