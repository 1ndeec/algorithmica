## Бинарное возведение в степень

### Идея

Заметим, что возвести число $a$ в степень $p$ можно быстрее, чем за $p -
1$ умножение. Мы будем пользоваться следующим соображением:

Если $p = 2q$, то $a^p = a^{2q} = \\left(a^q\\right)^2$. Значит, нам
достаточно посчитать $a^q$, чтобы посчитать $a^p$. Если $p = 2q +
1$, то просто посчитаем $a^{2q}$ и умножим на $a$.

### Реализация

Сразу напрашивается рекурсивная реализация этого алгоритма:

``` C++ numberLines
int binPow(int a, int p) {
    if (p == 0) {
        return 1;
    }
    int aq = binPow(a, p / 2);
    aq *= aq;
    if (p % 2 == 1) {
        aq *= p;
    }
    return aq;
}
```

Эта реализация - рекурсивная, что работает долго. Поэтому стоит
использовать <b>нерекурисвную</b>.

Опять рассмотрим двоичное представление числа $p$. Заведем текущую
степень числа $a$ - $a^t$. При проходе от младших разрядов к
старшим будем возводить текущую степень в квадрат, то есть $t$
увеличивается на каждом шаге в два раза. Если бит в текущем разряде
выставлен бит, то умножим набираемый ответ на текущую степень.

``` C++ numberLines
int fastBinPow(int a, int p) {
    int cur = a;
    int ans = 1;
    while (p > 0) {
        if (p & 1) {
            ans *= cur;
        }
        p /= 2;
        cur *= cur;
    }
    return ans;
}
```

### Асимптотика

В каждом из двух случаев делалось столько итераций цикла или вызовов,
сколько в числе бит, то есть все работает за $O(\\log n)$ при
условии, что умножение работает за $O(1)$.

[Категория:Конспект](Категория:Конспект "wikilink") [Категория:Теория
чисел](Категория:Теория_чисел "wikilink")