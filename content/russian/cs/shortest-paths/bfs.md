---
title: Поиск в ширину
authors:
- Максим Иванов
---

Поиск в ширину (обход в ширину, breadth-first search) — это один из основных алгоритмов на графах.

В результате поиска в ширину находится путь кратчайшей длины в невзвешенном графе, т.е. путь, содержащий наименьшее число рёбер.

Алгоритм работает за O (n+m), где n — число вершин, m — число рёбер.

Описание алгоритма
На вход алгоритма подаётся заданный граф (невзвешенный), и номер стартовой вершины s. Граф может быть как ориентированным, так и неориентированным, для алгоритма это не важно.

Сам алгоритм можно понимать как процесс "поджигания" графа: на нулевом шаге поджигаем только вершину s. На каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей; т.е. за одну итерацию алгоритма происходит расширение "кольца огня" в ширину на единицу (отсюда и название алгоритма).

Более строго это можно представить следующим образом. Создадим очередь q, в которую будут помещаться горящие вершины, а также заведём булевский массив \rm used[], в котором для каждой вершины будем отмечать, горит она уже или нет (или иными словами, была ли она посещена).

Изначально в очередь помещается только вершина s, и \rm used[s] = true, а для всех остальных вершин \rm used[] = false. Затем алгоритм представляет собой цикл: пока очередь не пуста, достать из её головы одну вершину, просмотреть все рёбра, исходящие из этой вершины, и если какие-то из просмотренных вершин ещё не горят, то поджечь их и поместить в конец очереди.

В итоге, когда очередь опустеет, обход в ширину обойдёт все достижимые из s вершины, причём до каждой дойдёт кратчайшим путём. Также можно посчитать длины кратчайших путей (для чего просто надо завести массив длин путей d[]), и компактно сохранить информацию, достаточную для восстановления всех этих кратчайших путей (для этого надо завести массив "предков" p[], в котором для каждой вершины хранить номер вершины, по которой мы попали в эту вершину).

Реализация
Реализуем вышеописанный алгоритм на языке C++.

Входные данные:

 
vector < vector<int> > g; // граф
int n; // число вершин
int s; // стартовая вершина (вершины везде нумеруются с нуля)
 
// чтение графа
...
Сам обход:

 
queue<int> q;
q.push (s);
vector<bool> used (n);
vector<int> d (n), p (n);
used[s] = true;
p[s] = -1;
while (!q.empty()) {
	int v = q.front();
	q.pop();
	for (size_t i=0; i<g[v].size(); ++i) {
		int to = g[v][i];
		if (!used[to]) {
			used[to] = true;
			q.push (to);
			d[to] = d[v] + 1;
			p[to] = v;
		}
	}
}
Если теперь надо восстановить и вывести кратчайший путь до какой-то вершины \rm to, это можно сделать следующим образом:

 
if (!used[to])
	cout << "No path!";
else {
	vector<int> path;
	for (int v=to; v!=-1; v=p[v])
		path.push_back (v);
	reverse (path.begin(), path.end());
	cout << "Path: ";
	for (size_t i=0; i<path.size(); ++i)
		cout << path[i] + 1 << " ";
}
Приложения алгоритма
Поиск кратчайшего пути в невзвешенном графе.
Поиск компонент связности в графе за O(n+m).
Для этого мы просто запускаем обход в ширину от каждой вершины, за исключением вершин, оставшихся посещёнными (\rm used=true) после предыдущих запусков. Таким образом, мы выполняем обычный запуск в ширину от каждой вершины, но не обнуляем каждый раз массив \rm used[], за счёт чего мы каждый раз будем обходить новую компоненту связности, а суммарное время работы алгоритма составит по-прежнему O(n+m) (такие несколько запусков обхода на графе без обнуления массива \rm used называются серией обходов в ширину).

Нахождения решения какой-либо задачи (игры) с наименьшим числом ходов, если каждое состояние системы можно представить вершиной графа, а переходы из одного состояния в другое — рёбрами графа.
Классический пример — игра, где робот двигается по полю, при этом он может передвигать ящики, находящиеся на этом же поле, и требуется за наименьшее число ходов передвинуть ящики в требуемые позиции. Решается это обходом в ширину по графу, где состоянием (вершиной) является набор координат: координаты робота, и координаты всех коробок.

Нахождение кратчайшего пути в 0-1-графе (т.е. графе взвешенном, но с весами равными только 0 либо 1): достаточно немного модифицировать поиск в ширину: если текущее ребро нулевого веса, и происходит улучшение расстояния до какой-то вершины, то эту вершину добавляем не в конец, а в начало очереди.
Нахождение кратчайшего цикла в ориентированном невзвешенном графе: производим поиск в ширину из каждой вершины; как только в процессе обхода мы пытаемся пойти из текущей вершины по какому-то ребру в уже посещённую вершину, то это означает, что мы нашли кратчайший цикл, и останавливаем обход в ширину; среди всех таких найденных циклов (по одному от каждого запуска обхода) выбираем кратчайший.
Найти все рёбра, лежащие на каком-либо кратчайшем пути между заданной парой вершин (a,b). Для этого надо запустить 2 поиска в ширину: из a, и из b. Обозначим через d_a[] массив кратчайших расстояний, полученный в результате первого обхода, а через d_b[] — в результате второго обхода. Теперь для любого ребра (u,v) легко проверить, лежит ли он на каком-либо кратчайшем пути: критерием будет условие d_a[u] + 1 + d_b[v] = d_a[b].
Найти все вершины, лежащие на каком-либо кратчайшем пути между заданной парой вершин (a,b). Для этого надо запустить 2 поиска в ширину: из a, и из b. Обозначим через d_a[] массив кратчайших расстояний, полученный в результате первого обхода, а через d_b[] — в результате второго обхода. Теперь для любой вершины v легко проверить, лежит ли он на каком-либо кратчайшем пути: критерием будет условие d_a[v] + d_b[v] = d_a[b].
Найти кратчайший чётный путь в графе (т.е. путь чётной длины). Для этого надо построить вспомогательный граф, вершинами которого будут состояния (v,c), где v — номер текущей вершины, c = 0 \ldots 1 — текущая чётность. Любое ребро (a,b) исходного графа в этом новом графе превратится в два ребра ((u,0),(v,1)) и ((u,1),(v,0)). После этого на этом графе надо обходом в ширину найти кратчайший путь из стартовой вершины в конечную, с чётностью, равной 0.


---

# 0-1 BFS

Задача: вам дан взвешенный граф $G$, веса рёбер которого принимают
значения $0$ ($0$-рёбра) и $1$ ($1$-рёбра) и выделена вершина $v$
в нём. Вас просят найти в этом графе кратчайшие расстояния от $v$ до
всех остальных вершин.

Идея: если от вершины $v_1$ до вершины $v_2$ можно дойти по пути,
состоящему из рёбер веса $0$, то кратчайшие расстояния до этих
вершин совпадают (Доказательство остаётся в качестве упражнения
читателю =) ).

Заметим тогда, что если в нашем графе оставить только $0$-рёбра, то он
распадётся на компоненты связности (возможно, некоторые будут иметь
размер $1$), в каждой из которых ответ одинаковый. Если теперь
вернуть $1$-рёбра, и сказать, что эти рёбра соединяют не вершины,
а компоненты связности, то мы сведём задачу к обычному
$\\textbf{BFS}$-у.

А чтобы решить исходную задачу, надо при посещении первой вершины из
компоненты обойти всю компоненту, проставив во всех вершинах такой
же ответ, как и у первой вершины. Как же можно обойти всю компоненту?
Запустить $\\textbf{BFS}$ на $0$-рёбрах\!.

А теперь заметим, что на самом деле нам не нужно запускать
$\\textbf{BFS}$ внутри $\\textbf{BFS}$, достаточно при посещении вершины
добавлять всех её непосещённых соседей по $0$-рёбрам в голову очереди,
чтобы обработать их раньше, чем следующие в очереди.

А какая структура данных позволяет нам добавлять вершины не только в
хвост, но и в голову? Это же дэк\!

В итоге, наш алгоритм выглядит примерно так:

``` C++
vector<int> zero-one-bfs(int start_vertex) {
    // длина любого кратчайшего пути не превосходит n - 1,
    // поэтому n - достаточное значение для "бесконечности";
    // после работы алгоритма dist[v] = n <=> v недостижима из s
    vector<int> dist(n, n);
    dist[s] = 0;
    deque<int> pending;
    pending.push_back(s);

    while (!q.empty()) {
        int v = pending.front();
        pending.pop_front();
        for (auto&& [to, w] /* конец ребра и его вес */ : adj[v]) {
            if (dist[to] > dist[v] + w) {
                dist[to] = dist[v] + w;
                if (w == 0) {
                    pending.push_front(to);
                } else {
                    pending.push_back(to);
                }
            }
        }
    }

    return dist;
}
```

---

### Эта страница содержит алгоритм 1-k BFS. Алгоритм 0-k BFS отличается от него только тем, что встречая рёбра веса 0, нам надо добавлять их в голову текущей очереди.

# 1-k BFS

Задача: вам дан взвешенный граф $G$, веса рёбер которого принимают
значения от $1$ до $k$ и выделена вершина $s$ в нём. Вас просят
найти в этом графе кратчайшие расстояния от $s$ до всех остальных
вершин.

### Наблюдение

Поскольку в графе нет рёбер отрицательного веса, то максимальное
кратчайшее расстояние в нём равно $(|V| - 1) \\times k$.

### Предложение 1

Давайте для каждого расстояния $d$ заведём $atdist\[d\]$ -- очередь
вершин, которые находятся на таком расстоянии от $s$ плюс,
возможно, некоторые вершины, до которых существует путь длины
$d$ от $s$, но для которых существует более короткий путь. Получится
$(|V| - 1) \\times k$ списков.

Как посчитать эти списки?

#### База

$atdist\[0\] = {s}$

#### Шаг

Если вершина $v$ лежит в списке $atdist\[d\]$, то любой из её ранее
непосещённых соседей, достижимых по ребру веса $w$ лежит в списке с
номером не более $atdist\[d+w\]$. Давайте тогда её добавим в этот
список. Однако, надо помнить, что на самом деле кратчайшее
расстояние до неё может быть и меньше, чем \[d+w\].

### Теорема

Если для всех вершин до уровня $d$ расстояния посчитаны корректно, то на
уровне $d+1$ сейчас находятся те вершины, до которых расстояние равно
$d+1$ плюс, возможно, дубликаты вершин, до которых мы в какой-то момент
нашли путь длины $d+1$, а затем нашли более короткий (разумеется, более
длинные пути мы не будем рассматривать).

Доказательство: по индукции.

### А нужно ли нам так много списков?

Заметим, что на самом деле мы можем обойтись $k+1$ списками, поскольку
обрабатывая рёбра, мы никогда не уходим вперёд на более, чем $k$
очередей, а старые очереди мы тем более не используем. Поэтому
вместо добавления в $atdist\[d+w\]$ мы будем добавлять в
$atdist\[(d+w) \\mod (atdist.size())\]$.

### Сложность алгоритма

$O(k|V| + |E|)$, поскольку после первого добавления вершины в какую-либо
очередь, в другие очереди мы сможем добавить её не более $k-1$ раз.

---

# 1-k BFS

Задача: вам дан взвешенный граф $G$, веса рёбер которого принимают
значения от $1$ до $k$ и выделена вершина $s$ в нём. Вас просят
найти в этом графе кратчайшие расстояния от $s$ до всех остальных
вершин.

### Наблюдение

Поскольку в графе нет рёбер отрицательного веса, то максимальное
кратчайшее расстояние в нём равно $(|V| - 1) \\times k$.

### Предложение

Давайте для каждого расстояния $d$ заведём $atdist\[d\]$ -- очередь
вершин, которые находятся на таком расстоянии от $s$ плюс,
возможно, некоторые вершины, до которых существует путь длины
$d$ от $s$, но для которых существует более короткий путь. Получится
$(|V| - 1) \\times k$ списков.

Как посчитать эти списки?

#### База

$atdist\[0\] = {s}$

#### Шаг

Если вершина $v$ лежит в списке $atdist\[d\]$, то любой из её ранее
непосещённых соседей, достижимых по ребру веса $w$ лежит в списке с
номером не более $atdist\[d+w\]$. Давайте тогда её добавим в этот
список. Однако, надо помнить, что на самом деле кратчайшее
расстояние до неё может быть и меньше, чем \[d+w\].

### Теорема

Если для всех вершин до уровня $d$ расстояния посчитаны корректно, то на
уровне $d+1$ сейчас находятся те вершины, до которых расстояние равно
$d+1$ плюс, возможно, дубликаты вершин, до которых мы в какой-то момент
нашли путь длины $d+1$, а затем нашли более короткий (разумеется, более
длинные пути мы не будем рассматривать).

Доказательство: по индукции.

### А нужно ли нам так много списков?

Заметим, что на самом деле мы можем обойтись $k+1$ списками, поскольку
обрабатывая рёбра, мы никогда не уходим вперёд на более, чем $k$
очередей, а старые очереди мы тем более не используем. Поэтому
вместо добавления в $atdist\[d+w\]$ мы будем добавлять в
$atdist\[(d+w) \\mod (atdist.size())\]$.

### Сложность алгоритма

$O(k|V| + |E|)$, поскольку каждую вершину мы можем прорелаксировать
(найти более оптимальный ответ) и добавить в другую очередь не более
$k$ раз, а просматривать рёбра, исходящие из вершины мы будем только
когда обнаружим эту вершину в самый первый раз.

---

# BFS

BFS — breadth-first search, или же поиск в ширину.

## Алгоритм

Алгоритм работает следующим образом.

1\. Создадим массив $dist$ расстояний. Изначально $dist\[s\] = 0$
(поскольку расстояний от вершины до самой себя равно $0$) и
$dist\[v\] = \\infty$ для $v \\neq s$.

2\. Создадим очередь $q$. Изначально в $q$ добавим вершину $s$.

3\. Пока очередь $q$ непуста, делаем следующее:

a) Извлекаем вершину $v$ из очереди.

b) Рассматриваем все рёбра $(v, u) \\in E$. Для каждого такого ребра
пытаемся сделать релаксацию: если $dist\[v\] + 1 \< dist\[u\]$, то
мы делаем присвоение $dist\[u\] = dist\[v\] + 1$ и добавляем вершину
$u$ в очередь.

## Визуализации:

  - <https://visualgo.net/mn/dfsbfs>

<!-- end list -->

  - <https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/visualize/>

## Интуитивное понимание алгоритма

Можно представить, что мы поджигаем вершину $s$. Каждый шаг алгоритма —
это распространение огня на соседние вершины. Понятно, что огонь
доберётся до вершины по кратчайшему пути.

Заметьте, что этот алгоритм очень похож на DFS — достаточно заменить
очередь на стек и поиск в ширину станет поиском в глубину.
Действительно, оба алгоритма при обработке вершины просто
записывают всех непосещенных соседей, в которые из неё есть ребро,
в структуру данных, и после этого выбирает следующую вершину для
обработки в структуре данных. В DFS это стек (благодаря
рекурсии), поэтому мы сначала записываем соседа, идем в
обрабатываем его полностью, а потом начинаем обрабатывать
следующего соседа. В BFS это очередь, поэтому мы кидаем сразу всех
соседей, а потом начинаем обрабатывать вообще другую вершину - ту
непосещенную, которую мы положили в очередь раньше всего.

Оба алгоритма позволяют обойти граф целиком - посетить каждую вершину
ровно один раз. Поэтому они оба подходят для таких задач как:

  - поиск компонент связности
  - проверка графа на двудольность
  - построение остова

## Реализация

``` C++
vector<int> bfs(int s) {
    // длина любого кратчайшего пути не превосходит n - 1,
    // поэтому n - достаточное значение для "бесконечности";
    // после работы алгоритма dist[v] = n, если v недостижима из s
    vector<int> dist(n, n);
    dist[s] = 0;
    queue<int> q;
    q.push(s);

    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int u : adj[v]) {
            if (dist[u] > dist[v] + 1) {
                dist[u] = dist[v] + 1;
                q.push(u);
            }
        }
    }

    return dist;
}
```

## Модификации и идеи

  - [Кратчайшее расстояние между двумя
    вершинами](Кратчайшее_расстояние_между_двумя_вершинами "wikilink")
  - [Кратчайшее расстояние от всех вершин графа до
    выделенных](Кратчайшее_расстояние_от_всех_вершин_графа_до_выделенных "wikilink")
  - [0-1 BFS](0-1_BFS "wikilink")
  - [1-k BFS](1-k_BFS "wikilink")