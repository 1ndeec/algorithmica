---
title: Поиск k-ой порядковой статистики
weight: 4
draft: true
---

В начале этой главы мы искали число элементов массива, не превосходящих $x$ (индекс этого элемента в отсортированном массиве), а теперь нас интересует обратная задача: какой элемент $k$-тый по возрастанию.

Если массив уже отсортирован, то задача тривиальная. Иначе мы его можем отсортировать, но на это потребуется $O(n \log n)$ операций — и мы знаем, что используя только сравнения быстрее не получится.

Есть другой подход — мы можем модифицировать

Пусть дан массив $A$ длиной $N$ и пусть дано число $K$. Задача заключается в том, чтобы найти в этом массиве $K$-ое по величине число, т.е. $K$-ую порядковую статистику.

Давайте поймем, что в быстрой сортировке мы можем узнать, сколько элементов меньше данного, тогда рассмотрим три случая

2. количество чисел, меньше данного = $k - 1$, тогда наше число - ответ.

3. количество чисел, меньше данного >= $k$, тогда спускаемся рекурсивно в левую часть и ищем там ответ.

4. количество чисел, меньше данного < $k$, спускаемся в правую ищем ($k$ - левая - 1) - ое число.

За сколько же это работает, из быстрой сортировки мы имеем, что размер убывает приблизительно в 2 раза, то есть мы имеем сумму $\sum_{k=1}^n {2 ^ k} = {2^{k+1}-1}$ что в нашем случае это максимум равно $2 * N - 1$, то есть $O(N)$.

```cpp
int kth(int *a, int n, int k) {
    int p = a[rand() % n];
    // ???
}
```

Также в C++ эта функция уже реализована и называется `nth_element` .
