---
title: Бинарный поиск
weight: 1
---

**Задача.** Загадано целое число $x$ от $1$ до $100$, которое вам нужно отгадать какой-нибудь «данеткой»: например, вы можете спрашивать, больше ли число $x$ чем заданное, или четно ли оно. За сколько вопросов в худшем случае вы сможете найти число $x$?

Одно из оптимальных решений имеет такую структуру: первым вопросом спрашиваем «больше ли число $x$, чем 50», и если ответ «да», то дальше спрашиваем «больше ли число $x$, чем 75», иначе «больше ли число $x$, чем 25», и повторяем дальше, каждый раз уменьшая отрезок возможных значений в два (или почти в два) раза.

Более структурно, если у нас есть отрезок поиска — изначально от $l=1$ до $r=100$ — то мы на каждой итерации выбираем «серединный» элемент $m = \lfloor \frac{l+r}{2} \rfloor$, спрашиваем «$x>m?$», выполняем присвоения $l = m + 1$ или $r = m$ в зависимости от ответа, и повторяем процедуру с новыми границами, пока они не станут равными (что будет означать, что $l = r = x$).

Вот пример такой программы, которую можно запустить в консоли:

```python
l, r = 1, 100

while l < r:
    m = (l + r) // 2
    resp = input(f'x > {m}? ')
    if resp == 'yes':
        l = m + 1
    else:
        r = m

print(f'x = {l}')
```

Если загадать $x=42$ и честно поотвечать на вопросы:

```
x > 50? no
x > 25? yes
x > 38? yes
x > 44? no
x > 41? yes
x > 43? no
x > 42? no
x = 42
```

Здесь нам потребовалось 7 вопросов. Всегда ли мы будем спрашивать ровно столько? Для этого нам нужно посчитать, сколько в худшем случае раз будет уменьшаться отрезок поиска. На каждой итерации его длина гарантированно уменьшится в два раза с округлением вверх.

Так как То есть деление отрезка ровно пополам гарантирует, что в худшем случае мы останемся не более чем с половиной вариантов

Пусть дан массив $a$, и требуется определить, есть ли в нём элемент $x$. Очевидно, в худшем случае этого элемента в массиве нет, но чтобы удостовериться в этом, нужно потратить $O(n)$ операций на просмотр всех элементов массива.

Однако иногда найти число $x$ в массиве можно и быстрее — например, если массив отсортирован. Но для этого сначала рассмотрим немного другую задачу.


**Примечание.** На самом деле, быстрее $O(\log n)$, а точнее $\lfloor \log n \rfloor$.


### Задание

Я загадал число X от 1 до 100. Вы можете спрашивать, больше ли мое число чем число T, я отвечаю "да" или "нет". За сколько вопросов в худшем случае вы сможете найти число X? Как нужно действовать?

**Решение** и состоит в идее бинарного (двоичного) поиска - нужно первым вопросом спросить "число X больше, чем 50?". После этого, если ответ "нет", надо спросить "число X больше, чем 25"? И так далее, нужно уменьшать отрезок возможных значений в два раза каждый раз.

Почему нужно делить обязательно пополам? Почему бы не спросить "число X больше, чем 80?" первым же вопросом? Но если вдруг ответ "нет", то мы останемся с 80 вариантами вместо 100. То есть деление отрезка ровно пополам гарантирует, что в худшем случае мы останемся не более чем с половиной вариантов.

Чтобы понять, как быстро это работает, введём новую математическую функцию. Логарифмом по основанию $a$ от $b$ будем называть число $c$, такое что $a ^ c = b$. Обозначается как $\log_a b = c$. Чаще всего мы будем работать с двоичным логарифмом, то есть в какую степень $c$ нужно возвести двойку, чтобы получить $b$. Поэтому договоримся, что запись $\log n$ означает двочный логарифм $n$.

Теперь вернёмся к нашей задаче. Можно понять, что такой алгоритм работает как раз за $O(\log n)$ вопросов (если число 100 на заменить абстрактную переменную $n$). Несложно убедиться, что именно логарифм раз нужно поделить число на два, чтобы получилось 1.

### Общий принцип

А теперь представьте такую задачу: у вас есть массив, состоящий из некоторого количества подряд идущих нулей, за которыми следует какое-то количество подряд идущих единиц.

```
a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1]
n = len(a)
n
```

```
14
```

Вам дан массив, и вам нужно найти позицию первой единицы, то есть найти такое место, где заканчиваются нули, и начинаются единицы. Это можно сделать с помощью линейного поиска за один проход по массиву, но хочется сделать это быстрее.

Давайте обратимся к идее **бинарного поиска**. Посмотрим на элемент посередине массива. Если это нуль, то первую единицу стоит искать в правой половину массива, а если единица - то в левой.

Есть много способов писать бинарный поиск, и в его написании люди очень часто путаются. Очень удобно в данном случае воспользоваться **инвариантом** (это слово значит "постоянное свойство"):

**Пусть переменная `left` всегда указывает на $0$ в массиве, а переменная `right` всегда указывает на $1$ в массиве**.

Дальше мы будем переменные `left` и `right` постепенно сдвигать друг к другу, и в какой-то момент они станут соседними числами. Это и будет означать, что мы нашли место, где заканчиваются нули и начинаются единицы.

Чему равны `left` и `right` изначально, когда мы ничего про массив не знаем? Первая приходящая в голову идея - поставить их на $0$ и $n-1$ соответственно. Увы, в общем случае это может быть неверно, потому что `a[0]` может быть единицей, а `a[n-1]` может быть нулём. Правильнее сделать вот так:

```
left = -1
right = n
```

То есть изначально `left` и `right` указывают на несуществующие индексы. Но это нормально - например в массиве `[1, 1, 1, 1]` в конце алгоритма как раз должно быть `left == -1`, `right == 0`.

Осталось нам написать цикл `while`:

```
while right - left > 1:
    middle = (left + right) // 2 # именно такая формула для среднего индекса между left и right
    if a[middle] == 1:
        right = middle # right всегда должна указывать на 1
    else:
        left = middle # left всегда должна указывать на 0
print left, right
print a[left], a[right]
```

```
8 9
0 1
```

Мы решили задачу для ноликов и единичек, но это легко обобщается на абсолютно любую задачу, где есть какое-то **свойство, которое в начале массива не выполняется, а потом выполняется**.

Например, если мы хотим найти, есть ли число $X$ в отсортированном массиве, то мы просто представим, что $0$ - это числа, меньшие $X$, а $1$ - это числа, большие или равные $X$. Тогда достаточно найти первую "единицу" и проверить, равно ли это число $X$.

```
a = [1, 3, 4, 10, 10, 10, 11, 80, 80, 81] # отсортированный массив
def bin_search(a, x):
    n = len(a)
    left = -1
    right = n
    while right - left > 1:
        middle = (left + right) // 2
        if a[middle] >= x: # практически единственная строка, которая меняется от задачи к задаче
            right = middle
        else:
            left = middle
    if right != n and a[right] == x: # ответ лежит в right
        return True
    else:
        return False

print (bin_search(a, 1))
print (bin_search(a, 10))
print (bin_search(a, 20))
print (bin_search(a, 79))
print (bin_search(a, 80))
print (bin_search(a, 81)
```

```
True
True
False
False
True
True
```

### Задание

Придумайте, как с помощью бинарного поиска решить такие задачи:

- Найти первое число, равное X в отсортированном массиве, или вывести, что таких чисел нет
- Найти последнее число, равное X в отсортированном массиве, или вывести, что таких чисел нет
- Посчитать, сколько раз встречается число X в отсортированном массиве (в решении помогают два предыдущих пункта)
- Дан массив чисел, первая часть состоит из нечетных чисел, а вторая - из четных. Найти индекс, начиная с которого все числа четные.

Все эти задачи решаются бинарным поиском за $O(\log{n})$. Правда нужно понимать, что в чистом виде такую задачу решать двоичным поиском бессмысленно - ведь чтобы создать массив размера $n$, уже необходимо потратить $O(n)$ операций.

Поэтому зачастую такие задачи сформулированы таким образом:

**Дан отсортированный массив размера $n$. Нужно ответить на $m$ запросов вида "встречается ли число $x_i$ в массиве n"?**

### Задание

Найдите время работы, за которое решается эта задача?

.

.

.

.

.

.

.

.

.

.

**Решение**: Такая задача решается за $O(n + m\log{n})$ - нужно создать массив за $O(n)$ и $m$ раз запустить бинарный поиск.

### Задание

Решите 3 первые задачи в этом контесте:

https://informatics.msk.ru/moodle/mod/statements/view.php?id=33216

### Бинарный поиск с вещественными числами

У нас все еще есть функция f(x), которая сначала равна 0, а потом равна 1, и мы хотим найти это место, где она меняет значение. Но теперь аргумент функции - вещественное число. Например:

- $f(x) = 1$, если $x^2 > 2$
- $f(x) = 0$, если $x^2 \leq 2$

Понятно, что при $x = \sqrt 2$ $f(x) = 0$, а при любом даже немного большем значении $f(x) = 1$. Если мы научимся решать такую задачу, то мы научимся находить корень из двух!

Увы, возникает проблема: **действительные числа хранятся в компьютере неточно**

```
# известный пример
0.1 + 0.1 + 0.1
```

```
0.30000000000000004
```

Тем более не сможем найти точное значение $\sqrt 2$, потому что это бесконечная непериодическая дробь. Так что давайте снова воспользуемся бинарным поиском, причем всегда $f(left) = 0$, $f(right) = 1$, и мы остановимся тогда, когда `left` и `right` будет очень-очень близко.

И тут снова возникает проблема. Помимо того, что бесконечную дробь в принципе невозможно точно хранить в компьютере, ещё и арифметические операции понижают эту точность. Поэтому, чтобы явно не использовать разность между правым и левым указателем, можно задать фиксированное число шагов, которое будет выполняться.

Так как мы знаем, что **двоичный** поиск работает за **двоичный** логарифм, можно сказать, что на угадывание десятичного разряда числа потребуется примерно три шага бинпоиска (т. к. $\log 10 \approx 3 $). Значит, например, если нам нужно посчитать значение функции до шести знаков после запятой, то нам нужно ещё примерно 18 шагов уже после того, как расстояние между `left` и `right` достигло одного.

Чтобы каждый раз об этом не думать, можно считать, что ста шагов бинпоиска хватит для почти любых разумных целей.

```
left = 0.0 # 0^2 < 2, а значит f(0) = 0
right = 10.0 # 10^2 > 2, а значит f(10) = 1
for i in range(100):
    middle = (left + right) / 2 # теперь деление не нацело, а вещественное
    if middle ** 2 > 2:
        right = middle # right всегда должна указывать на 1
    else:
        left = middle # left всегда должна указывать на 0
print left, right
print left ** 2, right ** 2
```

```
1.41421356237 1.41421356237
2.0 2.0
```

Вот мы и нашли корень из 2 с достаточно высокой точностью.

На самом деле, **так можно искать ноль любой непрерывной функции **(мы сейчас искали ноль функции $x^2 - 2$)**, у которой вы знаете значение меньше нуля и значение больше нуля**.

### Задание

Придумайте, как с помощью вещественного бинпоиска найти

- $\sqrt[\leftroot{-2}\uproot{2}17]{1000}$
- какой-нибудь корень уравнения $x^4 + 3x = 5$
